// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -1248550582;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__acknowledge_seed_warning_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "acknowledge_seed_warning",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::acknowledge_seed_warning()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__add_address_book_entry_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    address: impl CstDecode<String>,
    label: impl CstDecode<String>,
    notes: impl CstDecode<Option<String>>,
    color_tag: impl CstDecode<crate::models::AddressBookColorTag>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_address_book_entry",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_address = address.cst_decode();
            let api_label = label.cst_decode();
            let api_notes = notes.cst_decode();
            let api_color_tag = color_tag.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::add_address_book_entry(
                            api_wallet_id,
                            api_address,
                            api_label,
                            api_notes,
                            api_color_tag,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__address_exists_in_book_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    address: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "address_exists_in_book",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_address = address.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::address_exists_in_book(api_wallet_id, api_address)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__are_seed_screenshots_blocked_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "are_seed_screenshots_blocked",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::are_seed_screenshots_blocked()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__bootstrap_tunnel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mode: impl CstDecode<crate::models::TunnelMode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bootstrap_tunnel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mode = mode.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bootstrap_tunnel(api_mode).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__broadcast_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    signed: impl CstDecode<crate::models::SignedTx>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "broadcast_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_signed = signed.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::broadcast_tx(api_signed).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__build_consolidation_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    key_id: impl CstDecode<i64>,
    target_address: impl CstDecode<String>,
    fee_opt: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "build_consolidation_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_key_id = key_id.cst_decode();
            let api_target_address = target_address.cst_decode();
            let api_fee_opt = fee_opt.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::build_consolidation_tx(
                            api_wallet_id,
                            api_key_id,
                            api_target_address,
                            api_fee_opt,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__build_sweep_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    target_address: impl CstDecode<String>,
    fee_opt: impl CstDecode<Option<u64>>,
    key_ids_filter: impl CstDecode<Option<Vec<i64>>>,
    address_ids_filter: impl CstDecode<Option<Vec<i64>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "build_sweep_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_target_address = target_address.cst_decode();
            let api_fee_opt = fee_opt.cst_decode();
            let api_key_ids_filter = key_ids_filter.cst_decode();
            let api_address_ids_filter = address_ids_filter.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::build_sweep_tx(
                            api_wallet_id,
                            api_target_address,
                            api_fee_opt,
                            api_key_ids_filter,
                            api_address_ids_filter,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__build_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    outputs: impl CstDecode<Vec<crate::models::Output>>,
    fee_opt: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "build_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_outputs = outputs.cst_decode();
            let api_fee_opt = fee_opt.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::build_tx(api_wallet_id, api_outputs, api_fee_opt)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__build_tx_filtered_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    outputs: impl CstDecode<Vec<crate::models::Output>>,
    fee_opt: impl CstDecode<Option<u64>>,
    key_ids_filter: impl CstDecode<Option<Vec<i64>>>,
    address_ids_filter: impl CstDecode<Option<Vec<i64>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "build_tx_filtered",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_outputs = outputs.cst_decode();
            let api_fee_opt = fee_opt.cst_decode();
            let api_key_ids_filter = key_ids_filter.cst_decode();
            let api_address_ids_filter = address_ids_filter.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::build_tx_filtered(
                            api_wallet_id,
                            api_outputs,
                            api_fee_opt,
                            api_key_ids_filter,
                            api_address_ids_filter,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__build_tx_for_key_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    key_id: impl CstDecode<i64>,
    outputs: impl CstDecode<Vec<crate::models::Output>>,
    fee_opt: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "build_tx_for_key",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_key_id = key_id.cst_decode();
            let api_outputs = outputs.cst_decode();
            let api_fee_opt = fee_opt.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::build_tx_for_key(
                            api_wallet_id,
                            api_key_id,
                            api_outputs,
                            api_fee_opt,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__cancel_seed_export_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cancel_seed_export",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::cancel_seed_export()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__cancel_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cancel_sync",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::cancel_sync(api_wallet_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__change_app_passphrase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    current_passphrase: impl CstDecode<String>,
    new_passphrase: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "change_app_passphrase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_current_passphrase = current_passphrase.cst_decode();
            let api_new_passphrase = new_passphrase.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::change_app_passphrase(
                            api_current_passphrase,
                            api_new_passphrase,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__change_app_passphrase_with_cached_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    new_passphrase: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "change_app_passphrase_with_cached",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_new_passphrase = new_passphrase.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::change_app_passphrase_with_cached(api_new_passphrase)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__clear_duress_passphrase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_duress_passphrase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::clear_duress_passphrase()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__clear_panic_pin_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_panic_pin",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::clear_panic_pin()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__complete_seed_biometric_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    success: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "complete_seed_biometric",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_success = success.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::complete_seed_biometric(api_success)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__create_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    name: impl CstDecode<String>,
    _entropy_len: impl CstDecode<Option<u32>>,
    birthday_opt: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_name = name.cst_decode();
            let api__entropy_len = _entropy_len.cst_decode();
            let api_birthday_opt = birthday_opt.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::create_wallet(
                            api_name,
                            api__entropy_len,
                            api_birthday_opt,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__current_receive_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "current_receive_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::current_receive_address(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__delete_address_book_entry_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    id: impl CstDecode<i64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_address_book_entry",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_id = id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::delete_address_book_entry(api_wallet_id, api_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__delete_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::delete_wallet(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__estimate_fee_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    num_outputs: impl CstDecode<usize>,
    has_memo: impl CstDecode<bool>,
    fee_policy: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "estimate_fee",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_num_outputs = num_outputs.cst_decode();
            let api_has_memo = has_memo.cst_decode();
            let api_fee_policy = fee_policy.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::estimate_fee(
                            api_num_outputs,
                            api_has_memo,
                            api_fee_policy,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__exit_decoy_mode_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "exit_decoy_mode",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::exit_decoy_mode()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__export_ivk_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "export_ivk",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::export_ivk(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__export_ivk_secure_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "export_ivk_secure",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::export_ivk_secure(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__export_key_group_keys_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    key_id: impl CstDecode<i64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "export_key_group_keys",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_key_id = key_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::export_key_group_keys(api_wallet_id, api_key_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__export_orchard_ivk_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "export_orchard_ivk",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::export_orchard_ivk(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__export_orchard_viewing_key_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "export_orchard_viewing_key",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::export_orchard_viewing_key(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__export_seed_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "export_seed",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::export_seed(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__export_seed_with_cached_passphrase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "export_seed_with_cached_passphrase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::export_seed_with_cached_passphrase(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__export_seed_with_passphrase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    passphrase: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "export_seed_with_passphrase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_passphrase = passphrase.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::export_seed_with_passphrase(api_wallet_id, api_passphrase)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__fetch_transaction_memo_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    txid: impl CstDecode<String>,
    output_index: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fetch_transaction_memo",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_txid = txid.cst_decode();
            let api_output_index = output_index.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::fetch_transaction_memo(
                            api_wallet_id,
                            api_txid,
                            api_output_index,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__format_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    arrrtoshis: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "format_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_arrrtoshis = arrrtoshis.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::format_amount(api_arrrtoshis)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__generate_address_for_key_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    key_id: impl CstDecode<i64>,
    use_orchard: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "generate_address_for_key",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_key_id = key_id.cst_decode();
            let api_use_orchard = use_orchard.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::generate_address_for_key(
                            api_wallet_id,
                            api_key_id,
                            api_use_orchard,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__generate_mnemonic_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    word_count: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "generate_mnemonic",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_word_count = word_count.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::generate_mnemonic(api_word_count)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_active_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_active_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_active_wallet()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_address_book_count_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_address_book_count",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_address_book_count(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_address_book_entry_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    id: impl CstDecode<i64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_address_book_entry",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_id = id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_address_book_entry(api_wallet_id, api_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_address_book_entry_by_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    address: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_address_book_entry_by_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_address = address.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_address_book_entry_by_address(
                            api_wallet_id,
                            api_address,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_address_book_favorites_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_address_book_favorites",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_address_book_favorites(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_auto_consolidation_candidate_count_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_auto_consolidation_candidate_count",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::get_auto_consolidation_candidate_count(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_auto_consolidation_enabled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_auto_consolidation_enabled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_auto_consolidation_enabled(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_auto_consolidation_threshold_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_auto_consolidation_threshold",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_auto_consolidation_threshold()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_balance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_balance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_balance(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_build_info_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_build_info",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_build_info()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_checkpoint_details_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    _wallet_id: impl CstDecode<String>,
    height: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_checkpoint_details",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api__wallet_id = _wallet_id.cst_decode();
            let api_height = height.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::get_checkpoint_details(api__wallet_id, api_height)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_duress_passphrase_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_duress_passphrase_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_duress_passphrase_hash()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_fee_info_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_fee_info",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_fee_info()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_ivk_clipboard_remaining_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_ivk_clipboard_remaining",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_ivk_clipboard_remaining()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_label_for_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    address: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_label_for_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_address = address.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::get_label_for_address(api_wallet_id, api_address)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_last_checkpoint_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_last_checkpoint",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_last_checkpoint(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_lightd_endpoint_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_lightd_endpoint",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_lightd_endpoint(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_lightd_endpoint_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_lightd_endpoint_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_lightd_endpoint_config(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_network_info_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_network_info",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_network_info()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_recently_used_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    limit: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_recently_used_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_limit = limit.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::get_recently_used_addresses(api_wallet_id, api_limit)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_recommended_background_sync_mode_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    _wallet_id: impl CstDecode<String>,
    minutes_since_last: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_recommended_background_sync_mode",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api__wallet_id = _wallet_id.cst_decode();
            let api_minutes_since_last = minutes_since_last.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_recommended_background_sync_mode(
                            api__wallet_id,
                            api_minutes_since_last,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_seed_clipboard_remaining_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_seed_clipboard_remaining",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_seed_clipboard_remaining()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_seed_export_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_seed_export_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_seed_export_state()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_seed_export_warnings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_seed_export_warnings",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_seed_export_warnings()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_sync_logs_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    limit: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_sync_logs",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_limit = limit.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_sync_logs(api_wallet_id, api_limit)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_tor_status_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_tor_status",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::get_tor_status().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__get_tunnel_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_tunnel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_tunnel()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_vault_mode_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_vault_mode",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_vault_mode()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_watch_only_banner_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_watch_only_banner",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_watch_only_banner(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_watch_only_capabilities_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_watch_only_capabilities",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_watch_only_capabilities(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__has_app_passphrase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "has_app_passphrase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::has_app_passphrase()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__has_duress_passphrase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "has_duress_passphrase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::has_duress_passphrase()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__has_panic_pin_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "has_panic_pin",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::has_panic_pin()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__import_ivk_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    name: impl CstDecode<String>,
    sapling_ivk: impl CstDecode<Option<String>>,
    orchard_ivk: impl CstDecode<Option<String>>,
    birthday: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "import_ivk",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_name = name.cst_decode();
            let api_sapling_ivk = sapling_ivk.cst_decode();
            let api_orchard_ivk = orchard_ivk.cst_decode();
            let api_birthday = birthday.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::import_ivk(
                            api_name,
                            api_sapling_ivk,
                            api_orchard_ivk,
                            api_birthday,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__import_ivk_as_watch_only_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    name: impl CstDecode<String>,
    ivk: impl CstDecode<String>,
    birthday_height: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "import_ivk_as_watch_only",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_name = name.cst_decode();
            let api_ivk = ivk.cst_decode();
            let api_birthday_height = birthday_height.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::import_ivk_as_watch_only(
                            api_name,
                            api_ivk,
                            api_birthday_height,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__import_spending_key_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    sapling_key: impl CstDecode<Option<String>>,
    orchard_key: impl CstDecode<Option<String>>,
    label: impl CstDecode<Option<String>>,
    birthday_height: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "import_spending_key",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_sapling_key = sapling_key.cst_decode();
            let api_orchard_key = orchard_key.cst_decode();
            let api_label = label.cst_decode();
            let api_birthday_height = birthday_height.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::import_spending_key(
                            api_wallet_id,
                            api_sapling_key,
                            api_orchard_key,
                            api_label,
                            api_birthday_height,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__is_background_sync_needed_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_background_sync_needed",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::is_background_sync_needed(api_wallet_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__is_decoy_mode_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_decoy_mode",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::is_decoy_mode()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__is_sync_running_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_sync_running",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::is_sync_running(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__label_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    addr: impl CstDecode<String>,
    label: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "label_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_addr = addr.cst_decode();
            let api_label = label.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::label_address(api_wallet_id, api_addr, api_label)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__lightd_endpoint_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lightd_endpoint_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::LightdEndpoint::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lightd_endpoint_display_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::LightdEndpoint>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lightd_endpoint_display_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::LightdEndpoint::display_string(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lightd_endpoint_url_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::LightdEndpoint>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lightd_endpoint_url",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::LightdEndpoint::url(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__list_address_balances_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    key_id: impl CstDecode<Option<i64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "list_address_balances",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_key_id = key_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::list_address_balances(api_wallet_id, api_key_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__list_address_book_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "list_address_book",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::list_address_book(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__list_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "list_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::list_addresses(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__list_addresses_for_key_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    key_id: impl CstDecode<i64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "list_addresses_for_key",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_key_id = key_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::list_addresses_for_key(api_wallet_id, api_key_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__list_key_groups_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "list_key_groups",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::list_key_groups(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__list_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    limit: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "list_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_limit = limit.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::list_transactions(api_wallet_id, api_limit)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__list_wallets_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "list_wallets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::list_wallets()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__mark_address_used_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    address: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mark_address_used",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_address = address.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::mark_address_used(api_wallet_id, api_address)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__next_receive_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "next_receive_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::next_receive_address(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__parse_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    arrr: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "parse_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_arrr = arrr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::parse_amount(api_arrr)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__rename_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    new_name: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "rename_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_new_name = new_name.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::rename_wallet(api_wallet_id, api_new_name)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__rescan_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    from_height: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "rescan",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_from_height = from_height.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::rescan(api_wallet_id, api_from_height).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__reseal_db_keys_for_biometrics_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reseal_db_keys_for_biometrics",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::reseal_db_keys_for_biometrics()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__restore_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    name: impl CstDecode<String>,
    mnemonic: impl CstDecode<String>,
    passphrase_opt: impl CstDecode<Option<String>>,
    birthday_opt: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "restore_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_name = name.cst_decode();
            let api_mnemonic = mnemonic.cst_decode();
            let api_passphrase_opt = passphrase_opt.cst_decode();
            let api_birthday_opt = birthday_opt.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::restore_wallet(
                            api_name,
                            api_mnemonic,
                            api_passphrase_opt,
                            api_birthday_opt,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__rotate_tor_exit_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "rotate_tor_exit",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::rotate_tor_exit().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__search_address_book_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    query: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "search_address_book",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_query = query.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::search_address_book(api_wallet_id, api_query)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_address_color_tag_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    addr: impl CstDecode<String>,
    color_tag: impl CstDecode<crate::models::AddressBookColorTag>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_address_color_tag",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_addr = addr.cst_decode();
            let api_color_tag = color_tag.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::set_address_color_tag(
                            api_wallet_id,
                            api_addr,
                            api_color_tag,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_app_passphrase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    passphrase: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_app_passphrase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_passphrase = passphrase.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::set_app_passphrase(api_passphrase)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_auto_consolidation_enabled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    enabled: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_auto_consolidation_enabled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_enabled = enabled.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::set_auto_consolidation_enabled(api_wallet_id, api_enabled)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_decoy_wallet_name_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    name: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_decoy_wallet_name",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_name = name.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::set_decoy_wallet_name(api_name)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_duress_passphrase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    custom_passphrase: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_duress_passphrase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_custom_passphrase = custom_passphrase.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::set_duress_passphrase(api_custom_passphrase)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_lightd_endpoint_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    url: impl CstDecode<String>,
    tls_pin_opt: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_lightd_endpoint",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_url = url.cst_decode();
            let api_tls_pin_opt = tls_pin_opt.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::set_lightd_endpoint(
                            api_wallet_id,
                            api_url,
                            api_tls_pin_opt,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_panic_pin_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    pin: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_panic_pin",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_pin = pin.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::set_panic_pin(api_pin)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_tor_bridge_settings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    use_bridges: impl CstDecode<bool>,
    fallback_to_bridges: impl CstDecode<bool>,
    transport: impl CstDecode<String>,
    bridge_lines: impl CstDecode<Vec<String>>,
    transport_path: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tor_bridge_settings",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_use_bridges = use_bridges.cst_decode();
            let api_fallback_to_bridges = fallback_to_bridges.cst_decode();
            let api_transport = transport.cst_decode();
            let api_bridge_lines = bridge_lines.cst_decode();
            let api_transport_path = transport_path.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::set_tor_bridge_settings(
                            api_use_bridges,
                            api_fallback_to_bridges,
                            api_transport,
                            api_bridge_lines,
                            api_transport_path,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__set_tunnel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mode: impl CstDecode<crate::models::TunnelMode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tunnel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mode = mode.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::set_tunnel(api_mode)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_wallet_birthday_height_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    birthday_height: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_wallet_birthday_height",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_birthday_height = birthday_height.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::set_wallet_birthday_height(
                            api_wallet_id,
                            api_birthday_height,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__shutdown_transport_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "shutdown_transport",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::shutdown_transport().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sign_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    pending: impl CstDecode<crate::models::PendingTx>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sign_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_pending = pending.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::sign_tx(api_wallet_id, api_pending)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__sign_tx_filtered_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    pending: impl CstDecode<crate::models::PendingTx>,
    key_ids_filter: impl CstDecode<Option<Vec<i64>>>,
    address_ids_filter: impl CstDecode<Option<Vec<i64>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sign_tx_filtered",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_pending = pending.cst_decode();
            let api_key_ids_filter = key_ids_filter.cst_decode();
            let api_address_ids_filter = address_ids_filter.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::sign_tx_filtered(
                            api_wallet_id,
                            api_pending,
                            api_key_ids_filter,
                            api_address_ids_filter,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__sign_tx_for_key_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    pending: impl CstDecode<crate::models::PendingTx>,
    key_id: impl CstDecode<i64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sign_tx_for_key",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_pending = pending.cst_decode();
            let api_key_id = key_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::sign_tx_for_key(api_wallet_id, api_pending, api_key_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__skip_seed_biometric_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "skip_seed_biometric",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::skip_seed_biometric()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__start_background_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    mode: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "start_background_sync",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_mode = mode.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::start_background_sync(api_wallet_id, api_mode).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__start_background_sync_round_robin_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mode: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "start_background_sync_round_robin",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mode = mode.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::start_background_sync_round_robin(api_mode).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__start_seed_export_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "start_seed_export",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::start_seed_export(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__start_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    mode: impl CstDecode<crate::models::SyncMode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "start_sync",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_mode = mode.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::start_sync(api_wallet_id, api_mode).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__switch_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "switch_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::switch_wallet(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__sync_status_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sync_status",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::sync_status(api_wallet_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__test_node_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    url: impl CstDecode<String>,
    tls_pin: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "test_node",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_url = url.cst_decode();
            let api_tls_pin = tls_pin.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::test_node(api_url, api_tls_pin).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__toggle_address_book_favorite_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    id: impl CstDecode<i64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "toggle_address_book_favorite",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_id = id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::toggle_address_book_favorite(api_wallet_id, api_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__unlock_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    passphrase: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "unlock_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_passphrase = passphrase.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::unlock_app(api_passphrase)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__update_address_book_entry_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wallet_id: impl CstDecode<String>,
    id: impl CstDecode<i64>,
    label: impl CstDecode<Option<String>>,
    notes: impl CstDecode<Option<String>>,
    color_tag: impl CstDecode<Option<crate::models::AddressBookColorTag>>,
    is_favorite: impl CstDecode<Option<bool>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_address_book_entry",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wallet_id = wallet_id.cst_decode();
            let api_id = id.cst_decode();
            let api_label = label.cst_decode();
            let api_notes = notes.cst_decode();
            let api_color_tag = color_tag.cst_decode();
            let api_is_favorite = is_favorite.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::update_address_book_entry(
                            api_wallet_id,
                            api_id,
                            api_label,
                            api_notes,
                            api_color_tag,
                            api_is_favorite,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__validate_mnemonic_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "validate_mnemonic",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::validate_mnemonic(api_mnemonic)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__verify_app_passphrase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    passphrase: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "verify_app_passphrase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_passphrase = passphrase.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::verify_app_passphrase(api_passphrase)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__verify_duress_passphrase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    passphrase: impl CstDecode<String>,
    hash: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "verify_duress_passphrase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_passphrase = passphrase.cst_decode();
            let api_hash = hash.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::verify_duress_passphrase(api_passphrase, api_hash)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__verify_panic_pin_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    pin: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "verify_panic_pin",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_pin = pin.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::verify_panic_pin(api_pin)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__wallet_registry_exists_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_registry_exists",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::wallet_registry_exists()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__witness_refresh_outcome_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "witness_refresh_outcome_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::WitnessRefreshOutcome::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}

// Section: dart2rust

impl CstDecode<crate::models::AddressBookColorTag> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::models::AddressBookColorTag {
        match self {
            0 => crate::models::AddressBookColorTag::None,
            1 => crate::models::AddressBookColorTag::Red,
            2 => crate::models::AddressBookColorTag::Orange,
            3 => crate::models::AddressBookColorTag::Yellow,
            4 => crate::models::AddressBookColorTag::Green,
            5 => crate::models::AddressBookColorTag::Blue,
            6 => crate::models::AddressBookColorTag::Purple,
            7 => crate::models::AddressBookColorTag::Pink,
            8 => crate::models::AddressBookColorTag::Gray,
            _ => unreachable!("Invalid variant for AddressBookColorTag: {}", self),
        }
    }
}
impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<f64> for f64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> f64 {
        self
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<i64> for i64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i64 {
        self
    }
}
impl CstDecode<crate::models::KeyTypeInfo> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::models::KeyTypeInfo {
        match self {
            0 => crate::models::KeyTypeInfo::Seed,
            1 => crate::models::KeyTypeInfo::ImportedSpending,
            2 => crate::models::KeyTypeInfo::ImportedViewing,
            _ => unreachable!("Invalid variant for KeyTypeInfo: {}", self),
        }
    }
}
impl CstDecode<crate::models::SyncMode> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::models::SyncMode {
        match self {
            0 => crate::models::SyncMode::Compact,
            1 => crate::models::SyncMode::Deep,
            _ => unreachable!("Invalid variant for SyncMode: {}", self),
        }
    }
}
impl CstDecode<crate::models::SyncStage> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::models::SyncStage {
        match self {
            0 => crate::models::SyncStage::Headers,
            1 => crate::models::SyncStage::Notes,
            2 => crate::models::SyncStage::Witness,
            3 => crate::models::SyncStage::Verify,
            _ => unreachable!("Invalid variant for SyncStage: {}", self),
        }
    }
}
impl CstDecode<u16> for u16 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u16 {
        self
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::models::AddressBalanceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_balance = <u64>::sse_decode(deserializer);
        let mut var_spendable = <u64>::sse_decode(deserializer);
        let mut var_pending = <u64>::sse_decode(deserializer);
        let mut var_keyId = <Option<i64>>::sse_decode(deserializer);
        let mut var_addressId = <i64>::sse_decode(deserializer);
        let mut var_label = <Option<String>>::sse_decode(deserializer);
        let mut var_createdAt = <i64>::sse_decode(deserializer);
        let mut var_colorTag = <crate::models::AddressBookColorTag>::sse_decode(deserializer);
        let mut var_diversifierIndex = <u32>::sse_decode(deserializer);
        return crate::models::AddressBalanceInfo {
            address: var_address,
            balance: var_balance,
            spendable: var_spendable,
            pending: var_pending,
            key_id: var_keyId,
            address_id: var_addressId,
            label: var_label,
            created_at: var_createdAt,
            color_tag: var_colorTag,
            diversifier_index: var_diversifierIndex,
        };
    }
}

impl SseDecode for crate::models::AddressBookColorTag {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::AddressBookColorTag::None,
            1 => crate::models::AddressBookColorTag::Red,
            2 => crate::models::AddressBookColorTag::Orange,
            3 => crate::models::AddressBookColorTag::Yellow,
            4 => crate::models::AddressBookColorTag::Green,
            5 => crate::models::AddressBookColorTag::Blue,
            6 => crate::models::AddressBookColorTag::Purple,
            7 => crate::models::AddressBookColorTag::Pink,
            8 => crate::models::AddressBookColorTag::Gray,
            _ => unreachable!("Invalid variant for AddressBookColorTag: {}", inner),
        };
    }
}

impl SseDecode for crate::models::AddressBookEntryFfi {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i64>::sse_decode(deserializer);
        let mut var_walletId = <String>::sse_decode(deserializer);
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_label = <String>::sse_decode(deserializer);
        let mut var_notes = <Option<String>>::sse_decode(deserializer);
        let mut var_colorTag = <crate::models::AddressBookColorTag>::sse_decode(deserializer);
        let mut var_isFavorite = <bool>::sse_decode(deserializer);
        let mut var_createdAt = <i64>::sse_decode(deserializer);
        let mut var_updatedAt = <i64>::sse_decode(deserializer);
        let mut var_lastUsedAt = <Option<i64>>::sse_decode(deserializer);
        let mut var_useCount = <u32>::sse_decode(deserializer);
        return crate::models::AddressBookEntryFfi {
            id: var_id,
            wallet_id: var_walletId,
            address: var_address,
            label: var_label,
            notes: var_notes,
            color_tag: var_colorTag,
            is_favorite: var_isFavorite,
            created_at: var_createdAt,
            updated_at: var_updatedAt,
            last_used_at: var_lastUsedAt,
            use_count: var_useCount,
        };
    }
}

impl SseDecode for crate::models::AddressInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_diversifierIndex = <u32>::sse_decode(deserializer);
        let mut var_label = <Option<String>>::sse_decode(deserializer);
        let mut var_createdAt = <i64>::sse_decode(deserializer);
        let mut var_colorTag = <crate::models::AddressBookColorTag>::sse_decode(deserializer);
        return crate::models::AddressInfo {
            address: var_address,
            diversifier_index: var_diversifierIndex,
            label: var_label,
            created_at: var_createdAt,
            color_tag: var_colorTag,
        };
    }
}

impl SseDecode for crate::models::BackgroundSyncResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_mode = <String>::sse_decode(deserializer);
        let mut var_blocksSynced = <u64>::sse_decode(deserializer);
        let mut var_startHeight = <u64>::sse_decode(deserializer);
        let mut var_endHeight = <u64>::sse_decode(deserializer);
        let mut var_durationSecs = <u64>::sse_decode(deserializer);
        let mut var_errors = <Vec<String>>::sse_decode(deserializer);
        let mut var_newBalance = <Option<u64>>::sse_decode(deserializer);
        let mut var_newTransactions = <u32>::sse_decode(deserializer);
        return crate::models::BackgroundSyncResult {
            mode: var_mode,
            blocks_synced: var_blocksSynced,
            start_height: var_startHeight,
            end_height: var_endHeight,
            duration_secs: var_durationSecs,
            errors: var_errors,
            new_balance: var_newBalance,
            new_transactions: var_newTransactions,
        };
    }
}

impl SseDecode for crate::models::Balance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_total = <u64>::sse_decode(deserializer);
        let mut var_spendable = <u64>::sse_decode(deserializer);
        let mut var_pending = <u64>::sse_decode(deserializer);
        return crate::models::Balance {
            total: var_total,
            spendable: var_spendable,
            pending: var_pending,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::models::BuildInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_version = <String>::sse_decode(deserializer);
        let mut var_gitCommit = <String>::sse_decode(deserializer);
        let mut var_buildDate = <String>::sse_decode(deserializer);
        let mut var_rustVersion = <String>::sse_decode(deserializer);
        let mut var_targetTriple = <String>::sse_decode(deserializer);
        return crate::models::BuildInfo {
            version: var_version,
            git_commit: var_gitCommit,
            build_date: var_buildDate,
            rust_version: var_rustVersion,
            target_triple: var_targetTriple,
        };
    }
}

impl SseDecode for crate::api::CheckpointInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_height = <u32>::sse_decode(deserializer);
        let mut var_timestamp = <i64>::sse_decode(deserializer);
        return crate::api::CheckpointInfo {
            height: var_height,
            timestamp: var_timestamp,
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::FeeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_defaultFee = <u64>::sse_decode(deserializer);
        let mut var_minFee = <u64>::sse_decode(deserializer);
        let mut var_maxFee = <u64>::sse_decode(deserializer);
        let mut var_feePerOutput = <u64>::sse_decode(deserializer);
        let mut var_memoFeeMultiplier = <f64>::sse_decode(deserializer);
        return crate::api::FeeInfo {
            default_fee: var_defaultFee,
            min_fee: var_minFee,
            max_fee: var_maxFee,
            fee_per_output: var_feePerOutput,
            memo_fee_multiplier: var_memoFeeMultiplier,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::models::KeyAddressInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_keyId = <i64>::sse_decode(deserializer);
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_diversifierIndex = <u32>::sse_decode(deserializer);
        let mut var_label = <Option<String>>::sse_decode(deserializer);
        let mut var_createdAt = <i64>::sse_decode(deserializer);
        let mut var_colorTag = <crate::models::AddressBookColorTag>::sse_decode(deserializer);
        return crate::models::KeyAddressInfo {
            key_id: var_keyId,
            address: var_address,
            diversifier_index: var_diversifierIndex,
            label: var_label,
            created_at: var_createdAt,
            color_tag: var_colorTag,
        };
    }
}

impl SseDecode for crate::models::KeyExportInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_keyId = <i64>::sse_decode(deserializer);
        let mut var_saplingViewingKey = <Option<String>>::sse_decode(deserializer);
        let mut var_orchardViewingKey = <Option<String>>::sse_decode(deserializer);
        let mut var_saplingSpendingKey = <Option<String>>::sse_decode(deserializer);
        let mut var_orchardSpendingKey = <Option<String>>::sse_decode(deserializer);
        return crate::models::KeyExportInfo {
            key_id: var_keyId,
            sapling_viewing_key: var_saplingViewingKey,
            orchard_viewing_key: var_orchardViewingKey,
            sapling_spending_key: var_saplingSpendingKey,
            orchard_spending_key: var_orchardSpendingKey,
        };
    }
}

impl SseDecode for crate::models::KeyGroupInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i64>::sse_decode(deserializer);
        let mut var_label = <Option<String>>::sse_decode(deserializer);
        let mut var_keyType = <crate::models::KeyTypeInfo>::sse_decode(deserializer);
        let mut var_spendable = <bool>::sse_decode(deserializer);
        let mut var_hasSapling = <bool>::sse_decode(deserializer);
        let mut var_hasOrchard = <bool>::sse_decode(deserializer);
        let mut var_birthdayHeight = <i64>::sse_decode(deserializer);
        let mut var_createdAt = <i64>::sse_decode(deserializer);
        return crate::models::KeyGroupInfo {
            id: var_id,
            label: var_label,
            key_type: var_keyType,
            spendable: var_spendable,
            has_sapling: var_hasSapling,
            has_orchard: var_hasOrchard,
            birthday_height: var_birthdayHeight,
            created_at: var_createdAt,
        };
    }
}

impl SseDecode for crate::models::KeyTypeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::KeyTypeInfo::Seed,
            1 => crate::models::KeyTypeInfo::ImportedSpending,
            2 => crate::models::KeyTypeInfo::ImportedViewing,
            _ => unreachable!("Invalid variant for KeyTypeInfo: {}", inner),
        };
    }
}

impl SseDecode for crate::api::LightdEndpoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_host = <String>::sse_decode(deserializer);
        let mut var_port = <u16>::sse_decode(deserializer);
        let mut var_useTls = <bool>::sse_decode(deserializer);
        let mut var_tlsPin = <Option<String>>::sse_decode(deserializer);
        let mut var_label = <Option<String>>::sse_decode(deserializer);
        return crate::api::LightdEndpoint {
            host: var_host,
            port: var_port,
            use_tls: var_useTls,
            tls_pin: var_tlsPin,
            label: var_label,
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::AddressBalanceInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::AddressBalanceInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::AddressBookEntryFfi> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::AddressBookEntryFfi>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::AddressInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::AddressInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::KeyAddressInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::KeyAddressInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::KeyGroupInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::KeyGroupInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::Output> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::Output>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<i64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::SyncLogEntryFfi> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::SyncLogEntryFfi>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::TxInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::TxInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::WalletMeta> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::WalletMeta>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::models::NetworkInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_coinType = <u32>::sse_decode(deserializer);
        let mut var_rpcPort = <u16>::sse_decode(deserializer);
        let mut var_defaultBirthday = <u32>::sse_decode(deserializer);
        return crate::models::NetworkInfo {
            name: var_name,
            coin_type: var_coinType,
            rpc_port: var_rpcPort,
            default_birthday: var_defaultBirthday,
        };
    }
}

impl SseDecode for crate::models::NodeTestResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_latestBlockHeight = <Option<u64>>::sse_decode(deserializer);
        let mut var_transportMode = <String>::sse_decode(deserializer);
        let mut var_tlsEnabled = <bool>::sse_decode(deserializer);
        let mut var_tlsPinMatched = <Option<bool>>::sse_decode(deserializer);
        let mut var_expectedPin = <Option<String>>::sse_decode(deserializer);
        let mut var_actualPin = <Option<String>>::sse_decode(deserializer);
        let mut var_errorMessage = <Option<String>>::sse_decode(deserializer);
        let mut var_responseTimeMs = <u64>::sse_decode(deserializer);
        let mut var_serverVersion = <Option<String>>::sse_decode(deserializer);
        let mut var_chainName = <Option<String>>::sse_decode(deserializer);
        return crate::models::NodeTestResult {
            success: var_success,
            latest_block_height: var_latestBlockHeight,
            transport_mode: var_transportMode,
            tls_enabled: var_tlsEnabled,
            tls_pin_matched: var_tlsPinMatched,
            expected_pin: var_expectedPin,
            actual_pin: var_actualPin,
            error_message: var_errorMessage,
            response_time_ms: var_responseTimeMs,
            server_version: var_serverVersion,
            chain_name: var_chainName,
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::AddressBookColorTag> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::AddressBookColorTag>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::AddressBookEntryFfi> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::AddressBookEntryFfi>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::CheckpointInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::CheckpointInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::WatchOnlyBannerInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::WatchOnlyBannerInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<i64>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<i64>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::models::Output {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_addr = <String>::sse_decode(deserializer);
        let mut var_amount = <u64>::sse_decode(deserializer);
        let mut var_memo = <Option<String>>::sse_decode(deserializer);
        return crate::models::Output {
            addr: var_addr,
            amount: var_amount,
            memo: var_memo,
        };
    }
}

impl SseDecode for crate::models::PendingTx {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_outputs = <Vec<crate::models::Output>>::sse_decode(deserializer);
        let mut var_totalAmount = <u64>::sse_decode(deserializer);
        let mut var_fee = <u64>::sse_decode(deserializer);
        let mut var_change = <u64>::sse_decode(deserializer);
        let mut var_inputTotal = <u64>::sse_decode(deserializer);
        let mut var_numInputs = <u32>::sse_decode(deserializer);
        let mut var_expiryHeight = <u32>::sse_decode(deserializer);
        let mut var_createdAt = <i64>::sse_decode(deserializer);
        return crate::models::PendingTx {
            id: var_id,
            outputs: var_outputs,
            total_amount: var_totalAmount,
            fee: var_fee,
            change: var_change,
            input_total: var_inputTotal,
            num_inputs: var_numInputs,
            expiry_height: var_expiryHeight,
            created_at: var_createdAt,
        };
    }
}

impl SseDecode for crate::api::SeedExportWarnings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_primary = <String>::sse_decode(deserializer);
        let mut var_secondary = <String>::sse_decode(deserializer);
        let mut var_backupInstructions = <String>::sse_decode(deserializer);
        let mut var_clipboardWarning = <String>::sse_decode(deserializer);
        return crate::api::SeedExportWarnings {
            primary: var_primary,
            secondary: var_secondary,
            backup_instructions: var_backupInstructions,
            clipboard_warning: var_clipboardWarning,
        };
    }
}

impl SseDecode for crate::models::SignedTx {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_raw = <Vec<u8>>::sse_decode(deserializer);
        let mut var_size = <usize>::sse_decode(deserializer);
        return crate::models::SignedTx {
            txid: var_txid,
            raw: var_raw,
            size: var_size,
        };
    }
}

impl SseDecode for crate::models::SyncLogEntryFfi {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_timestamp = <i64>::sse_decode(deserializer);
        let mut var_level = <String>::sse_decode(deserializer);
        let mut var_module = <String>::sse_decode(deserializer);
        let mut var_message = <String>::sse_decode(deserializer);
        return crate::models::SyncLogEntryFfi {
            timestamp: var_timestamp,
            level: var_level,
            module: var_module,
            message: var_message,
        };
    }
}

impl SseDecode for crate::models::SyncMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::SyncMode::Compact,
            1 => crate::models::SyncMode::Deep,
            _ => unreachable!("Invalid variant for SyncMode: {}", inner),
        };
    }
}

impl SseDecode for crate::models::SyncStage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::SyncStage::Headers,
            1 => crate::models::SyncStage::Notes,
            2 => crate::models::SyncStage::Witness,
            3 => crate::models::SyncStage::Verify,
            _ => unreachable!("Invalid variant for SyncStage: {}", inner),
        };
    }
}

impl SseDecode for crate::models::SyncStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_localHeight = <u64>::sse_decode(deserializer);
        let mut var_targetHeight = <u64>::sse_decode(deserializer);
        let mut var_percent = <f64>::sse_decode(deserializer);
        let mut var_eta = <Option<u64>>::sse_decode(deserializer);
        let mut var_stage = <crate::models::SyncStage>::sse_decode(deserializer);
        let mut var_lastCheckpoint = <Option<u64>>::sse_decode(deserializer);
        let mut var_blocksPerSecond = <f64>::sse_decode(deserializer);
        let mut var_notesDecrypted = <u64>::sse_decode(deserializer);
        let mut var_lastBatchMs = <u64>::sse_decode(deserializer);
        return crate::models::SyncStatus {
            local_height: var_localHeight,
            target_height: var_targetHeight,
            percent: var_percent,
            eta: var_eta,
            stage: var_stage,
            last_checkpoint: var_lastCheckpoint,
            blocks_per_second: var_blocksPerSecond,
            notes_decrypted: var_notesDecrypted,
            last_batch_ms: var_lastBatchMs,
        };
    }
}

impl SseDecode for crate::models::TunnelMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::models::TunnelMode::Tor;
            }
            1 => {
                return crate::models::TunnelMode::I2p;
            }
            2 => {
                let mut var_url = <String>::sse_decode(deserializer);
                return crate::models::TunnelMode::Socks5 { url: var_url };
            }
            3 => {
                return crate::models::TunnelMode::Direct;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::TxInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_height = <Option<u32>>::sse_decode(deserializer);
        let mut var_timestamp = <i64>::sse_decode(deserializer);
        let mut var_amount = <i64>::sse_decode(deserializer);
        let mut var_fee = <u64>::sse_decode(deserializer);
        let mut var_memo = <Option<String>>::sse_decode(deserializer);
        let mut var_confirmed = <bool>::sse_decode(deserializer);
        return crate::models::TxInfo {
            txid: var_txid,
            height: var_height,
            timestamp: var_timestamp,
            amount: var_amount,
            fee: var_fee,
            memo: var_memo,
            confirmed: var_confirmed,
        };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::models::WalletBackgroundSyncResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_walletId = <String>::sse_decode(deserializer);
        let mut var_mode = <String>::sse_decode(deserializer);
        let mut var_blocksSynced = <u64>::sse_decode(deserializer);
        let mut var_startHeight = <u64>::sse_decode(deserializer);
        let mut var_endHeight = <u64>::sse_decode(deserializer);
        let mut var_durationSecs = <u64>::sse_decode(deserializer);
        let mut var_errors = <Vec<String>>::sse_decode(deserializer);
        let mut var_newBalance = <Option<u64>>::sse_decode(deserializer);
        let mut var_newTransactions = <u32>::sse_decode(deserializer);
        return crate::models::WalletBackgroundSyncResult {
            wallet_id: var_walletId,
            mode: var_mode,
            blocks_synced: var_blocksSynced,
            start_height: var_startHeight,
            end_height: var_endHeight,
            duration_secs: var_durationSecs,
            errors: var_errors,
            new_balance: var_newBalance,
            new_transactions: var_newTransactions,
        };
    }
}

impl SseDecode for crate::models::WalletMeta {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_createdAt = <i64>::sse_decode(deserializer);
        let mut var_watchOnly = <bool>::sse_decode(deserializer);
        let mut var_birthdayHeight = <u32>::sse_decode(deserializer);
        let mut var_networkType = <Option<String>>::sse_decode(deserializer);
        return crate::models::WalletMeta {
            id: var_id,
            name: var_name,
            created_at: var_createdAt,
            watch_only: var_watchOnly,
            birthday_height: var_birthdayHeight,
            network_type: var_networkType,
        };
    }
}

impl SseDecode for crate::api::WatchOnlyBannerInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bannerType = <String>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_subtitle = <String>::sse_decode(deserializer);
        let mut var_icon = <String>::sse_decode(deserializer);
        return crate::api::WatchOnlyBannerInfo {
            banner_type: var_bannerType,
            title: var_title,
            subtitle: var_subtitle,
            icon: var_icon,
        };
    }
}

impl SseDecode for crate::api::WatchOnlyCapabilitiesInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_canViewIncoming = <bool>::sse_decode(deserializer);
        let mut var_canViewOutgoing = <bool>::sse_decode(deserializer);
        let mut var_canSpend = <bool>::sse_decode(deserializer);
        let mut var_canExportSeed = <bool>::sse_decode(deserializer);
        let mut var_canGenerateAddresses = <bool>::sse_decode(deserializer);
        let mut var_isWatchOnly = <bool>::sse_decode(deserializer);
        return crate::api::WatchOnlyCapabilitiesInfo {
            can_view_incoming: var_canViewIncoming,
            can_view_outgoing: var_canViewOutgoing,
            can_spend: var_canSpend,
            can_export_seed: var_canExportSeed,
            can_generate_addresses: var_canGenerateAddresses,
            is_watch_only: var_isWatchOnly,
        };
    }
}

impl SseDecode for crate::api::WitnessRefreshOutcome {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_source = <String>::sse_decode(deserializer);
        let mut var_saplingRequested = <usize>::sse_decode(deserializer);
        let mut var_saplingUpdated = <usize>::sse_decode(deserializer);
        let mut var_saplingMissing = <usize>::sse_decode(deserializer);
        let mut var_saplingErrors = <usize>::sse_decode(deserializer);
        let mut var_orchardRequested = <usize>::sse_decode(deserializer);
        let mut var_orchardUpdated = <usize>::sse_decode(deserializer);
        let mut var_orchardMissing = <usize>::sse_decode(deserializer);
        let mut var_orchardErrors = <usize>::sse_decode(deserializer);
        return crate::api::WitnessRefreshOutcome {
            source: var_source,
            sapling_requested: var_saplingRequested,
            sapling_updated: var_saplingUpdated,
            sapling_missing: var_saplingMissing,
            sapling_errors: var_saplingErrors,
            orchard_requested: var_orchardRequested,
            orchard_updated: var_orchardUpdated,
            orchard_missing: var_orchardMissing,
            orchard_errors: var_orchardErrors,
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::AddressBalanceInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.address.into_into_dart().into_dart(),
            self.balance.into_into_dart().into_dart(),
            self.spendable.into_into_dart().into_dart(),
            self.pending.into_into_dart().into_dart(),
            self.key_id.into_into_dart().into_dart(),
            self.address_id.into_into_dart().into_dart(),
            self.label.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
            self.color_tag.into_into_dart().into_dart(),
            self.diversifier_index.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::AddressBalanceInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::AddressBalanceInfo>
    for crate::models::AddressBalanceInfo
{
    fn into_into_dart(self) -> crate::models::AddressBalanceInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::AddressBookColorTag {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::None => 0.into_dart(),
            Self::Red => 1.into_dart(),
            Self::Orange => 2.into_dart(),
            Self::Yellow => 3.into_dart(),
            Self::Green => 4.into_dart(),
            Self::Blue => 5.into_dart(),
            Self::Purple => 6.into_dart(),
            Self::Pink => 7.into_dart(),
            Self::Gray => 8.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::AddressBookColorTag
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::AddressBookColorTag>
    for crate::models::AddressBookColorTag
{
    fn into_into_dart(self) -> crate::models::AddressBookColorTag {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::AddressBookEntryFfi {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.wallet_id.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
            self.label.into_into_dart().into_dart(),
            self.notes.into_into_dart().into_dart(),
            self.color_tag.into_into_dart().into_dart(),
            self.is_favorite.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
            self.updated_at.into_into_dart().into_dart(),
            self.last_used_at.into_into_dart().into_dart(),
            self.use_count.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::AddressBookEntryFfi
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::AddressBookEntryFfi>
    for crate::models::AddressBookEntryFfi
{
    fn into_into_dart(self) -> crate::models::AddressBookEntryFfi {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::AddressInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.address.into_into_dart().into_dart(),
            self.diversifier_index.into_into_dart().into_dart(),
            self.label.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
            self.color_tag.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::AddressInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::AddressInfo> for crate::models::AddressInfo {
    fn into_into_dart(self) -> crate::models::AddressInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::BackgroundSyncResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.mode.into_into_dart().into_dart(),
            self.blocks_synced.into_into_dart().into_dart(),
            self.start_height.into_into_dart().into_dart(),
            self.end_height.into_into_dart().into_dart(),
            self.duration_secs.into_into_dart().into_dart(),
            self.errors.into_into_dart().into_dart(),
            self.new_balance.into_into_dart().into_dart(),
            self.new_transactions.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::BackgroundSyncResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::BackgroundSyncResult>
    for crate::models::BackgroundSyncResult
{
    fn into_into_dart(self) -> crate::models::BackgroundSyncResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::Balance {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.total.into_into_dart().into_dart(),
            self.spendable.into_into_dart().into_dart(),
            self.pending.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::Balance {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::Balance> for crate::models::Balance {
    fn into_into_dart(self) -> crate::models::Balance {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::BuildInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.version.into_into_dart().into_dart(),
            self.git_commit.into_into_dart().into_dart(),
            self.build_date.into_into_dart().into_dart(),
            self.rust_version.into_into_dart().into_dart(),
            self.target_triple.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::BuildInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::BuildInfo> for crate::models::BuildInfo {
    fn into_into_dart(self) -> crate::models::BuildInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::CheckpointInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.height.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::CheckpointInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::CheckpointInfo> for crate::api::CheckpointInfo {
    fn into_into_dart(self) -> crate::api::CheckpointInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::FeeInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.default_fee.into_into_dart().into_dart(),
            self.min_fee.into_into_dart().into_dart(),
            self.max_fee.into_into_dart().into_dart(),
            self.fee_per_output.into_into_dart().into_dart(),
            self.memo_fee_multiplier.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::FeeInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::FeeInfo> for crate::api::FeeInfo {
    fn into_into_dart(self) -> crate::api::FeeInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::KeyAddressInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.key_id.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
            self.diversifier_index.into_into_dart().into_dart(),
            self.label.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
            self.color_tag.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::KeyAddressInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::KeyAddressInfo>
    for crate::models::KeyAddressInfo
{
    fn into_into_dart(self) -> crate::models::KeyAddressInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::KeyExportInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.key_id.into_into_dart().into_dart(),
            self.sapling_viewing_key.into_into_dart().into_dart(),
            self.orchard_viewing_key.into_into_dart().into_dart(),
            self.sapling_spending_key.into_into_dart().into_dart(),
            self.orchard_spending_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::KeyExportInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::KeyExportInfo>
    for crate::models::KeyExportInfo
{
    fn into_into_dart(self) -> crate::models::KeyExportInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::KeyGroupInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.label.into_into_dart().into_dart(),
            self.key_type.into_into_dart().into_dart(),
            self.spendable.into_into_dart().into_dart(),
            self.has_sapling.into_into_dart().into_dart(),
            self.has_orchard.into_into_dart().into_dart(),
            self.birthday_height.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::KeyGroupInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::KeyGroupInfo>
    for crate::models::KeyGroupInfo
{
    fn into_into_dart(self) -> crate::models::KeyGroupInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::KeyTypeInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Seed => 0.into_dart(),
            Self::ImportedSpending => 1.into_dart(),
            Self::ImportedViewing => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::KeyTypeInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::KeyTypeInfo> for crate::models::KeyTypeInfo {
    fn into_into_dart(self) -> crate::models::KeyTypeInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::LightdEndpoint {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.host.into_into_dart().into_dart(),
            self.port.into_into_dart().into_dart(),
            self.use_tls.into_into_dart().into_dart(),
            self.tls_pin.into_into_dart().into_dart(),
            self.label.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::LightdEndpoint {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::LightdEndpoint> for crate::api::LightdEndpoint {
    fn into_into_dart(self) -> crate::api::LightdEndpoint {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::NetworkInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.coin_type.into_into_dart().into_dart(),
            self.rpc_port.into_into_dart().into_dart(),
            self.default_birthday.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::NetworkInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::NetworkInfo> for crate::models::NetworkInfo {
    fn into_into_dart(self) -> crate::models::NetworkInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::NodeTestResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.latest_block_height.into_into_dart().into_dart(),
            self.transport_mode.into_into_dart().into_dart(),
            self.tls_enabled.into_into_dart().into_dart(),
            self.tls_pin_matched.into_into_dart().into_dart(),
            self.expected_pin.into_into_dart().into_dart(),
            self.actual_pin.into_into_dart().into_dart(),
            self.error_message.into_into_dart().into_dart(),
            self.response_time_ms.into_into_dart().into_dart(),
            self.server_version.into_into_dart().into_dart(),
            self.chain_name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::NodeTestResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::NodeTestResult>
    for crate::models::NodeTestResult
{
    fn into_into_dart(self) -> crate::models::NodeTestResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::Output {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.addr.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
            self.memo.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::Output {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::Output> for crate::models::Output {
    fn into_into_dart(self) -> crate::models::Output {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::PendingTx {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.outputs.into_into_dart().into_dart(),
            self.total_amount.into_into_dart().into_dart(),
            self.fee.into_into_dart().into_dart(),
            self.change.into_into_dart().into_dart(),
            self.input_total.into_into_dart().into_dart(),
            self.num_inputs.into_into_dart().into_dart(),
            self.expiry_height.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::PendingTx {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::PendingTx> for crate::models::PendingTx {
    fn into_into_dart(self) -> crate::models::PendingTx {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::SeedExportWarnings {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.primary.into_into_dart().into_dart(),
            self.secondary.into_into_dart().into_dart(),
            self.backup_instructions.into_into_dart().into_dart(),
            self.clipboard_warning.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::SeedExportWarnings
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::SeedExportWarnings>
    for crate::api::SeedExportWarnings
{
    fn into_into_dart(self) -> crate::api::SeedExportWarnings {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::SignedTx {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.raw.into_into_dart().into_dart(),
            self.size.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::SignedTx {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::SignedTx> for crate::models::SignedTx {
    fn into_into_dart(self) -> crate::models::SignedTx {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::SyncLogEntryFfi {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.timestamp.into_into_dart().into_dart(),
            self.level.into_into_dart().into_dart(),
            self.module.into_into_dart().into_dart(),
            self.message.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::SyncLogEntryFfi
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::SyncLogEntryFfi>
    for crate::models::SyncLogEntryFfi
{
    fn into_into_dart(self) -> crate::models::SyncLogEntryFfi {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::SyncMode {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Compact => 0.into_dart(),
            Self::Deep => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::SyncMode {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::SyncMode> for crate::models::SyncMode {
    fn into_into_dart(self) -> crate::models::SyncMode {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::SyncStage {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Headers => 0.into_dart(),
            Self::Notes => 1.into_dart(),
            Self::Witness => 2.into_dart(),
            Self::Verify => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::SyncStage {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::SyncStage> for crate::models::SyncStage {
    fn into_into_dart(self) -> crate::models::SyncStage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::SyncStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.local_height.into_into_dart().into_dart(),
            self.target_height.into_into_dart().into_dart(),
            self.percent.into_into_dart().into_dart(),
            self.eta.into_into_dart().into_dart(),
            self.stage.into_into_dart().into_dart(),
            self.last_checkpoint.into_into_dart().into_dart(),
            self.blocks_per_second.into_into_dart().into_dart(),
            self.notes_decrypted.into_into_dart().into_dart(),
            self.last_batch_ms.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::SyncStatus {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::SyncStatus> for crate::models::SyncStatus {
    fn into_into_dart(self) -> crate::models::SyncStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::TunnelMode {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::TunnelMode::Tor => [0.into_dart()].into_dart(),
            crate::models::TunnelMode::I2p => [1.into_dart()].into_dart(),
            crate::models::TunnelMode::Socks5 { url } => {
                [2.into_dart(), url.into_into_dart().into_dart()].into_dart()
            }
            crate::models::TunnelMode::Direct => [3.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::TunnelMode {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::TunnelMode> for crate::models::TunnelMode {
    fn into_into_dart(self) -> crate::models::TunnelMode {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::TxInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
            self.fee.into_into_dart().into_dart(),
            self.memo.into_into_dart().into_dart(),
            self.confirmed.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::TxInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::TxInfo> for crate::models::TxInfo {
    fn into_into_dart(self) -> crate::models::TxInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::WalletBackgroundSyncResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.wallet_id.into_into_dart().into_dart(),
            self.mode.into_into_dart().into_dart(),
            self.blocks_synced.into_into_dart().into_dart(),
            self.start_height.into_into_dart().into_dart(),
            self.end_height.into_into_dart().into_dart(),
            self.duration_secs.into_into_dart().into_dart(),
            self.errors.into_into_dart().into_dart(),
            self.new_balance.into_into_dart().into_dart(),
            self.new_transactions.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::WalletBackgroundSyncResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::WalletBackgroundSyncResult>
    for crate::models::WalletBackgroundSyncResult
{
    fn into_into_dart(self) -> crate::models::WalletBackgroundSyncResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::WalletMeta {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
            self.watch_only.into_into_dart().into_dart(),
            self.birthday_height.into_into_dart().into_dart(),
            self.network_type.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::WalletMeta {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::WalletMeta> for crate::models::WalletMeta {
    fn into_into_dart(self) -> crate::models::WalletMeta {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::WatchOnlyBannerInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.banner_type.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.subtitle.into_into_dart().into_dart(),
            self.icon.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::WatchOnlyBannerInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::WatchOnlyBannerInfo>
    for crate::api::WatchOnlyBannerInfo
{
    fn into_into_dart(self) -> crate::api::WatchOnlyBannerInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::WatchOnlyCapabilitiesInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.can_view_incoming.into_into_dart().into_dart(),
            self.can_view_outgoing.into_into_dart().into_dart(),
            self.can_spend.into_into_dart().into_dart(),
            self.can_export_seed.into_into_dart().into_dart(),
            self.can_generate_addresses.into_into_dart().into_dart(),
            self.is_watch_only.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::WatchOnlyCapabilitiesInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::WatchOnlyCapabilitiesInfo>
    for crate::api::WatchOnlyCapabilitiesInfo
{
    fn into_into_dart(self) -> crate::api::WatchOnlyCapabilitiesInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::WitnessRefreshOutcome {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.source.into_into_dart().into_dart(),
            self.sapling_requested.into_into_dart().into_dart(),
            self.sapling_updated.into_into_dart().into_dart(),
            self.sapling_missing.into_into_dart().into_dart(),
            self.sapling_errors.into_into_dart().into_dart(),
            self.orchard_requested.into_into_dart().into_dart(),
            self.orchard_updated.into_into_dart().into_dart(),
            self.orchard_missing.into_into_dart().into_dart(),
            self.orchard_errors.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::WitnessRefreshOutcome
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::WitnessRefreshOutcome>
    for crate::api::WitnessRefreshOutcome
{
    fn into_into_dart(self) -> crate::api::WitnessRefreshOutcome {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::models::AddressBalanceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
        <u64>::sse_encode(self.balance, serializer);
        <u64>::sse_encode(self.spendable, serializer);
        <u64>::sse_encode(self.pending, serializer);
        <Option<i64>>::sse_encode(self.key_id, serializer);
        <i64>::sse_encode(self.address_id, serializer);
        <Option<String>>::sse_encode(self.label, serializer);
        <i64>::sse_encode(self.created_at, serializer);
        <crate::models::AddressBookColorTag>::sse_encode(self.color_tag, serializer);
        <u32>::sse_encode(self.diversifier_index, serializer);
    }
}

impl SseEncode for crate::models::AddressBookColorTag {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::AddressBookColorTag::None => 0,
                crate::models::AddressBookColorTag::Red => 1,
                crate::models::AddressBookColorTag::Orange => 2,
                crate::models::AddressBookColorTag::Yellow => 3,
                crate::models::AddressBookColorTag::Green => 4,
                crate::models::AddressBookColorTag::Blue => 5,
                crate::models::AddressBookColorTag::Purple => 6,
                crate::models::AddressBookColorTag::Pink => 7,
                crate::models::AddressBookColorTag::Gray => 8,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::AddressBookEntryFfi {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.wallet_id, serializer);
        <String>::sse_encode(self.address, serializer);
        <String>::sse_encode(self.label, serializer);
        <Option<String>>::sse_encode(self.notes, serializer);
        <crate::models::AddressBookColorTag>::sse_encode(self.color_tag, serializer);
        <bool>::sse_encode(self.is_favorite, serializer);
        <i64>::sse_encode(self.created_at, serializer);
        <i64>::sse_encode(self.updated_at, serializer);
        <Option<i64>>::sse_encode(self.last_used_at, serializer);
        <u32>::sse_encode(self.use_count, serializer);
    }
}

impl SseEncode for crate::models::AddressInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
        <u32>::sse_encode(self.diversifier_index, serializer);
        <Option<String>>::sse_encode(self.label, serializer);
        <i64>::sse_encode(self.created_at, serializer);
        <crate::models::AddressBookColorTag>::sse_encode(self.color_tag, serializer);
    }
}

impl SseEncode for crate::models::BackgroundSyncResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.mode, serializer);
        <u64>::sse_encode(self.blocks_synced, serializer);
        <u64>::sse_encode(self.start_height, serializer);
        <u64>::sse_encode(self.end_height, serializer);
        <u64>::sse_encode(self.duration_secs, serializer);
        <Vec<String>>::sse_encode(self.errors, serializer);
        <Option<u64>>::sse_encode(self.new_balance, serializer);
        <u32>::sse_encode(self.new_transactions, serializer);
    }
}

impl SseEncode for crate::models::Balance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.total, serializer);
        <u64>::sse_encode(self.spendable, serializer);
        <u64>::sse_encode(self.pending, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::models::BuildInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.version, serializer);
        <String>::sse_encode(self.git_commit, serializer);
        <String>::sse_encode(self.build_date, serializer);
        <String>::sse_encode(self.rust_version, serializer);
        <String>::sse_encode(self.target_triple, serializer);
    }
}

impl SseEncode for crate::api::CheckpointInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.height, serializer);
        <i64>::sse_encode(self.timestamp, serializer);
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::FeeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.default_fee, serializer);
        <u64>::sse_encode(self.min_fee, serializer);
        <u64>::sse_encode(self.max_fee, serializer);
        <u64>::sse_encode(self.fee_per_output, serializer);
        <f64>::sse_encode(self.memo_fee_multiplier, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::models::KeyAddressInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.key_id, serializer);
        <String>::sse_encode(self.address, serializer);
        <u32>::sse_encode(self.diversifier_index, serializer);
        <Option<String>>::sse_encode(self.label, serializer);
        <i64>::sse_encode(self.created_at, serializer);
        <crate::models::AddressBookColorTag>::sse_encode(self.color_tag, serializer);
    }
}

impl SseEncode for crate::models::KeyExportInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.key_id, serializer);
        <Option<String>>::sse_encode(self.sapling_viewing_key, serializer);
        <Option<String>>::sse_encode(self.orchard_viewing_key, serializer);
        <Option<String>>::sse_encode(self.sapling_spending_key, serializer);
        <Option<String>>::sse_encode(self.orchard_spending_key, serializer);
    }
}

impl SseEncode for crate::models::KeyGroupInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.id, serializer);
        <Option<String>>::sse_encode(self.label, serializer);
        <crate::models::KeyTypeInfo>::sse_encode(self.key_type, serializer);
        <bool>::sse_encode(self.spendable, serializer);
        <bool>::sse_encode(self.has_sapling, serializer);
        <bool>::sse_encode(self.has_orchard, serializer);
        <i64>::sse_encode(self.birthday_height, serializer);
        <i64>::sse_encode(self.created_at, serializer);
    }
}

impl SseEncode for crate::models::KeyTypeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::KeyTypeInfo::Seed => 0,
                crate::models::KeyTypeInfo::ImportedSpending => 1,
                crate::models::KeyTypeInfo::ImportedViewing => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::LightdEndpoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.host, serializer);
        <u16>::sse_encode(self.port, serializer);
        <bool>::sse_encode(self.use_tls, serializer);
        <Option<String>>::sse_encode(self.tls_pin, serializer);
        <Option<String>>::sse_encode(self.label, serializer);
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::AddressBalanceInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::AddressBalanceInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::AddressBookEntryFfi> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::AddressBookEntryFfi>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::AddressInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::AddressInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::KeyAddressInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::KeyAddressInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::KeyGroupInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::KeyGroupInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::Output> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::Output>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <i64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::SyncLogEntryFfi> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::SyncLogEntryFfi>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::TxInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::TxInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::WalletMeta> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::WalletMeta>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::models::NetworkInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <u32>::sse_encode(self.coin_type, serializer);
        <u16>::sse_encode(self.rpc_port, serializer);
        <u32>::sse_encode(self.default_birthday, serializer);
    }
}

impl SseEncode for crate::models::NodeTestResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <Option<u64>>::sse_encode(self.latest_block_height, serializer);
        <String>::sse_encode(self.transport_mode, serializer);
        <bool>::sse_encode(self.tls_enabled, serializer);
        <Option<bool>>::sse_encode(self.tls_pin_matched, serializer);
        <Option<String>>::sse_encode(self.expected_pin, serializer);
        <Option<String>>::sse_encode(self.actual_pin, serializer);
        <Option<String>>::sse_encode(self.error_message, serializer);
        <u64>::sse_encode(self.response_time_ms, serializer);
        <Option<String>>::sse_encode(self.server_version, serializer);
        <Option<String>>::sse_encode(self.chain_name, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::AddressBookColorTag> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::AddressBookColorTag>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::AddressBookEntryFfi> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::AddressBookEntryFfi>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::CheckpointInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::CheckpointInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::WatchOnlyBannerInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::WatchOnlyBannerInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<i64>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<i64>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::models::Output {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.addr, serializer);
        <u64>::sse_encode(self.amount, serializer);
        <Option<String>>::sse_encode(self.memo, serializer);
    }
}

impl SseEncode for crate::models::PendingTx {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <Vec<crate::models::Output>>::sse_encode(self.outputs, serializer);
        <u64>::sse_encode(self.total_amount, serializer);
        <u64>::sse_encode(self.fee, serializer);
        <u64>::sse_encode(self.change, serializer);
        <u64>::sse_encode(self.input_total, serializer);
        <u32>::sse_encode(self.num_inputs, serializer);
        <u32>::sse_encode(self.expiry_height, serializer);
        <i64>::sse_encode(self.created_at, serializer);
    }
}

impl SseEncode for crate::api::SeedExportWarnings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.primary, serializer);
        <String>::sse_encode(self.secondary, serializer);
        <String>::sse_encode(self.backup_instructions, serializer);
        <String>::sse_encode(self.clipboard_warning, serializer);
    }
}

impl SseEncode for crate::models::SignedTx {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <Vec<u8>>::sse_encode(self.raw, serializer);
        <usize>::sse_encode(self.size, serializer);
    }
}

impl SseEncode for crate::models::SyncLogEntryFfi {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.timestamp, serializer);
        <String>::sse_encode(self.level, serializer);
        <String>::sse_encode(self.module, serializer);
        <String>::sse_encode(self.message, serializer);
    }
}

impl SseEncode for crate::models::SyncMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::SyncMode::Compact => 0,
                crate::models::SyncMode::Deep => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::SyncStage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::SyncStage::Headers => 0,
                crate::models::SyncStage::Notes => 1,
                crate::models::SyncStage::Witness => 2,
                crate::models::SyncStage::Verify => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::SyncStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.local_height, serializer);
        <u64>::sse_encode(self.target_height, serializer);
        <f64>::sse_encode(self.percent, serializer);
        <Option<u64>>::sse_encode(self.eta, serializer);
        <crate::models::SyncStage>::sse_encode(self.stage, serializer);
        <Option<u64>>::sse_encode(self.last_checkpoint, serializer);
        <f64>::sse_encode(self.blocks_per_second, serializer);
        <u64>::sse_encode(self.notes_decrypted, serializer);
        <u64>::sse_encode(self.last_batch_ms, serializer);
    }
}

impl SseEncode for crate::models::TunnelMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::TunnelMode::Tor => {
                <i32>::sse_encode(0, serializer);
            }
            crate::models::TunnelMode::I2p => {
                <i32>::sse_encode(1, serializer);
            }
            crate::models::TunnelMode::Socks5 { url } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(url, serializer);
            }
            crate::models::TunnelMode::Direct => {
                <i32>::sse_encode(3, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::TxInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <Option<u32>>::sse_encode(self.height, serializer);
        <i64>::sse_encode(self.timestamp, serializer);
        <i64>::sse_encode(self.amount, serializer);
        <u64>::sse_encode(self.fee, serializer);
        <Option<String>>::sse_encode(self.memo, serializer);
        <bool>::sse_encode(self.confirmed, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::models::WalletBackgroundSyncResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.wallet_id, serializer);
        <String>::sse_encode(self.mode, serializer);
        <u64>::sse_encode(self.blocks_synced, serializer);
        <u64>::sse_encode(self.start_height, serializer);
        <u64>::sse_encode(self.end_height, serializer);
        <u64>::sse_encode(self.duration_secs, serializer);
        <Vec<String>>::sse_encode(self.errors, serializer);
        <Option<u64>>::sse_encode(self.new_balance, serializer);
        <u32>::sse_encode(self.new_transactions, serializer);
    }
}

impl SseEncode for crate::models::WalletMeta {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.name, serializer);
        <i64>::sse_encode(self.created_at, serializer);
        <bool>::sse_encode(self.watch_only, serializer);
        <u32>::sse_encode(self.birthday_height, serializer);
        <Option<String>>::sse_encode(self.network_type, serializer);
    }
}

impl SseEncode for crate::api::WatchOnlyBannerInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.banner_type, serializer);
        <String>::sse_encode(self.title, serializer);
        <String>::sse_encode(self.subtitle, serializer);
        <String>::sse_encode(self.icon, serializer);
    }
}

impl SseEncode for crate::api::WatchOnlyCapabilitiesInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.can_view_incoming, serializer);
        <bool>::sse_encode(self.can_view_outgoing, serializer);
        <bool>::sse_encode(self.can_spend, serializer);
        <bool>::sse_encode(self.can_export_seed, serializer);
        <bool>::sse_encode(self.can_generate_addresses, serializer);
        <bool>::sse_encode(self.is_watch_only, serializer);
    }
}

impl SseEncode for crate::api::WitnessRefreshOutcome {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.source, serializer);
        <usize>::sse_encode(self.sapling_requested, serializer);
        <usize>::sse_encode(self.sapling_updated, serializer);
        <usize>::sse_encode(self.sapling_missing, serializer);
        <usize>::sse_encode(self.sapling_errors, serializer);
        <usize>::sse_encode(self.orchard_requested, serializer);
        <usize>::sse_encode(self.orchard_updated, serializer);
        <usize>::sse_encode(self.orchard_missing, serializer);
        <usize>::sse_encode(self.orchard_errors, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    // Section: dart2rust

    impl CstDecode<flutter_rust_bridge::for_generated::anyhow::Error>
        for *mut wire_cst_list_prim_u_8_strict
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::for_generated::anyhow::Error {
            unimplemented!()
        }
    }
    impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            let vec: Vec<u8> = self.cst_decode();
            String::from_utf8(vec).unwrap()
        }
    }
    impl CstDecode<crate::models::AddressBalanceInfo> for wire_cst_address_balance_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::AddressBalanceInfo {
            crate::models::AddressBalanceInfo {
                address: self.address.cst_decode(),
                balance: self.balance.cst_decode(),
                spendable: self.spendable.cst_decode(),
                pending: self.pending.cst_decode(),
                key_id: self.key_id.cst_decode(),
                address_id: self.address_id.cst_decode(),
                label: self.label.cst_decode(),
                created_at: self.created_at.cst_decode(),
                color_tag: self.color_tag.cst_decode(),
                diversifier_index: self.diversifier_index.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::AddressBookEntryFfi> for wire_cst_address_book_entry_ffi {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::AddressBookEntryFfi {
            crate::models::AddressBookEntryFfi {
                id: self.id.cst_decode(),
                wallet_id: self.wallet_id.cst_decode(),
                address: self.address.cst_decode(),
                label: self.label.cst_decode(),
                notes: self.notes.cst_decode(),
                color_tag: self.color_tag.cst_decode(),
                is_favorite: self.is_favorite.cst_decode(),
                created_at: self.created_at.cst_decode(),
                updated_at: self.updated_at.cst_decode(),
                last_used_at: self.last_used_at.cst_decode(),
                use_count: self.use_count.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::AddressInfo> for wire_cst_address_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::AddressInfo {
            crate::models::AddressInfo {
                address: self.address.cst_decode(),
                diversifier_index: self.diversifier_index.cst_decode(),
                label: self.label.cst_decode(),
                created_at: self.created_at.cst_decode(),
                color_tag: self.color_tag.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::BackgroundSyncResult> for wire_cst_background_sync_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::BackgroundSyncResult {
            crate::models::BackgroundSyncResult {
                mode: self.mode.cst_decode(),
                blocks_synced: self.blocks_synced.cst_decode(),
                start_height: self.start_height.cst_decode(),
                end_height: self.end_height.cst_decode(),
                duration_secs: self.duration_secs.cst_decode(),
                errors: self.errors.cst_decode(),
                new_balance: self.new_balance.cst_decode(),
                new_transactions: self.new_transactions.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::Balance> for wire_cst_balance {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::Balance {
            crate::models::Balance {
                total: self.total.cst_decode(),
                spendable: self.spendable.cst_decode(),
                pending: self.pending.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::AddressBookColorTag> for *mut i32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::AddressBookColorTag {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::models::AddressBookColorTag>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::models::AddressBookEntryFfi> for *mut wire_cst_address_book_entry_ffi {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::AddressBookEntryFfi {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::models::AddressBookEntryFfi>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<bool> for *mut bool {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> bool {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::api::CheckpointInfo> for *mut wire_cst_checkpoint_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::CheckpointInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::CheckpointInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<i64> for *mut i64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> i64 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::api::LightdEndpoint> for *mut wire_cst_lightd_endpoint {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::LightdEndpoint {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::LightdEndpoint>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::models::PendingTx> for *mut wire_cst_pending_tx {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::PendingTx {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::models::PendingTx>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::models::SignedTx> for *mut wire_cst_signed_tx {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::SignedTx {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::models::SignedTx>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::models::TunnelMode> for *mut wire_cst_tunnel_mode {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::TunnelMode {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::models::TunnelMode>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<u32> for *mut u32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u64> for *mut u64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u64 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::api::WatchOnlyBannerInfo> for *mut wire_cst_watch_only_banner_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::WatchOnlyBannerInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::WatchOnlyBannerInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::models::BuildInfo> for wire_cst_build_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::BuildInfo {
            crate::models::BuildInfo {
                version: self.version.cst_decode(),
                git_commit: self.git_commit.cst_decode(),
                build_date: self.build_date.cst_decode(),
                rust_version: self.rust_version.cst_decode(),
                target_triple: self.target_triple.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::CheckpointInfo> for wire_cst_checkpoint_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::CheckpointInfo {
            crate::api::CheckpointInfo {
                height: self.height.cst_decode(),
                timestamp: self.timestamp.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::FeeInfo> for wire_cst_fee_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::FeeInfo {
            crate::api::FeeInfo {
                default_fee: self.default_fee.cst_decode(),
                min_fee: self.min_fee.cst_decode(),
                max_fee: self.max_fee.cst_decode(),
                fee_per_output: self.fee_per_output.cst_decode(),
                memo_fee_multiplier: self.memo_fee_multiplier.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::KeyAddressInfo> for wire_cst_key_address_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::KeyAddressInfo {
            crate::models::KeyAddressInfo {
                key_id: self.key_id.cst_decode(),
                address: self.address.cst_decode(),
                diversifier_index: self.diversifier_index.cst_decode(),
                label: self.label.cst_decode(),
                created_at: self.created_at.cst_decode(),
                color_tag: self.color_tag.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::KeyExportInfo> for wire_cst_key_export_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::KeyExportInfo {
            crate::models::KeyExportInfo {
                key_id: self.key_id.cst_decode(),
                sapling_viewing_key: self.sapling_viewing_key.cst_decode(),
                orchard_viewing_key: self.orchard_viewing_key.cst_decode(),
                sapling_spending_key: self.sapling_spending_key.cst_decode(),
                orchard_spending_key: self.orchard_spending_key.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::KeyGroupInfo> for wire_cst_key_group_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::KeyGroupInfo {
            crate::models::KeyGroupInfo {
                id: self.id.cst_decode(),
                label: self.label.cst_decode(),
                key_type: self.key_type.cst_decode(),
                spendable: self.spendable.cst_decode(),
                has_sapling: self.has_sapling.cst_decode(),
                has_orchard: self.has_orchard.cst_decode(),
                birthday_height: self.birthday_height.cst_decode(),
                created_at: self.created_at.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::LightdEndpoint> for wire_cst_lightd_endpoint {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::LightdEndpoint {
            crate::api::LightdEndpoint {
                host: self.host.cst_decode(),
                port: self.port.cst_decode(),
                use_tls: self.use_tls.cst_decode(),
                tls_pin: self.tls_pin.cst_decode(),
                label: self.label.cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<String>> for *mut wire_cst_list_String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<String> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::models::AddressBalanceInfo>> for *mut wire_cst_list_address_balance_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::AddressBalanceInfo> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::models::AddressBookEntryFfi>>
        for *mut wire_cst_list_address_book_entry_ffi
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::AddressBookEntryFfi> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::models::AddressInfo>> for *mut wire_cst_list_address_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::AddressInfo> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::models::KeyAddressInfo>> for *mut wire_cst_list_key_address_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::KeyAddressInfo> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::models::KeyGroupInfo>> for *mut wire_cst_list_key_group_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::KeyGroupInfo> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::models::Output>> for *mut wire_cst_list_output {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::Output> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<i64>> for *mut wire_cst_list_prim_i_64_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<i64> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<crate::models::SyncLogEntryFfi>> for *mut wire_cst_list_sync_log_entry_ffi {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::SyncLogEntryFfi> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::models::TxInfo>> for *mut wire_cst_list_tx_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::TxInfo> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::models::WalletMeta>> for *mut wire_cst_list_wallet_meta {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::WalletMeta> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<crate::models::NetworkInfo> for wire_cst_network_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::NetworkInfo {
            crate::models::NetworkInfo {
                name: self.name.cst_decode(),
                coin_type: self.coin_type.cst_decode(),
                rpc_port: self.rpc_port.cst_decode(),
                default_birthday: self.default_birthday.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::NodeTestResult> for wire_cst_node_test_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::NodeTestResult {
            crate::models::NodeTestResult {
                success: self.success.cst_decode(),
                latest_block_height: self.latest_block_height.cst_decode(),
                transport_mode: self.transport_mode.cst_decode(),
                tls_enabled: self.tls_enabled.cst_decode(),
                tls_pin_matched: self.tls_pin_matched.cst_decode(),
                expected_pin: self.expected_pin.cst_decode(),
                actual_pin: self.actual_pin.cst_decode(),
                error_message: self.error_message.cst_decode(),
                response_time_ms: self.response_time_ms.cst_decode(),
                server_version: self.server_version.cst_decode(),
                chain_name: self.chain_name.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::Output> for wire_cst_output {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::Output {
            crate::models::Output {
                addr: self.addr.cst_decode(),
                amount: self.amount.cst_decode(),
                memo: self.memo.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::PendingTx> for wire_cst_pending_tx {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::PendingTx {
            crate::models::PendingTx {
                id: self.id.cst_decode(),
                outputs: self.outputs.cst_decode(),
                total_amount: self.total_amount.cst_decode(),
                fee: self.fee.cst_decode(),
                change: self.change.cst_decode(),
                input_total: self.input_total.cst_decode(),
                num_inputs: self.num_inputs.cst_decode(),
                expiry_height: self.expiry_height.cst_decode(),
                created_at: self.created_at.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::SeedExportWarnings> for wire_cst_seed_export_warnings {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::SeedExportWarnings {
            crate::api::SeedExportWarnings {
                primary: self.primary.cst_decode(),
                secondary: self.secondary.cst_decode(),
                backup_instructions: self.backup_instructions.cst_decode(),
                clipboard_warning: self.clipboard_warning.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::SignedTx> for wire_cst_signed_tx {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::SignedTx {
            crate::models::SignedTx {
                txid: self.txid.cst_decode(),
                raw: self.raw.cst_decode(),
                size: self.size.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::SyncLogEntryFfi> for wire_cst_sync_log_entry_ffi {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::SyncLogEntryFfi {
            crate::models::SyncLogEntryFfi {
                timestamp: self.timestamp.cst_decode(),
                level: self.level.cst_decode(),
                module: self.module.cst_decode(),
                message: self.message.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::SyncStatus> for wire_cst_sync_status {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::SyncStatus {
            crate::models::SyncStatus {
                local_height: self.local_height.cst_decode(),
                target_height: self.target_height.cst_decode(),
                percent: self.percent.cst_decode(),
                eta: self.eta.cst_decode(),
                stage: self.stage.cst_decode(),
                last_checkpoint: self.last_checkpoint.cst_decode(),
                blocks_per_second: self.blocks_per_second.cst_decode(),
                notes_decrypted: self.notes_decrypted.cst_decode(),
                last_batch_ms: self.last_batch_ms.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::TunnelMode> for wire_cst_tunnel_mode {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::TunnelMode {
            match self.tag {
                0 => crate::models::TunnelMode::Tor,
                1 => crate::models::TunnelMode::I2p,
                2 => {
                    let ans = unsafe { self.kind.Socks5 };
                    crate::models::TunnelMode::Socks5 {
                        url: ans.url.cst_decode(),
                    }
                }
                3 => crate::models::TunnelMode::Direct,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::models::TxInfo> for wire_cst_tx_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::TxInfo {
            crate::models::TxInfo {
                txid: self.txid.cst_decode(),
                height: self.height.cst_decode(),
                timestamp: self.timestamp.cst_decode(),
                amount: self.amount.cst_decode(),
                fee: self.fee.cst_decode(),
                memo: self.memo.cst_decode(),
                confirmed: self.confirmed.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::WalletBackgroundSyncResult>
        for wire_cst_wallet_background_sync_result
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::WalletBackgroundSyncResult {
            crate::models::WalletBackgroundSyncResult {
                wallet_id: self.wallet_id.cst_decode(),
                mode: self.mode.cst_decode(),
                blocks_synced: self.blocks_synced.cst_decode(),
                start_height: self.start_height.cst_decode(),
                end_height: self.end_height.cst_decode(),
                duration_secs: self.duration_secs.cst_decode(),
                errors: self.errors.cst_decode(),
                new_balance: self.new_balance.cst_decode(),
                new_transactions: self.new_transactions.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::WalletMeta> for wire_cst_wallet_meta {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::WalletMeta {
            crate::models::WalletMeta {
                id: self.id.cst_decode(),
                name: self.name.cst_decode(),
                created_at: self.created_at.cst_decode(),
                watch_only: self.watch_only.cst_decode(),
                birthday_height: self.birthday_height.cst_decode(),
                network_type: self.network_type.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::WatchOnlyBannerInfo> for wire_cst_watch_only_banner_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::WatchOnlyBannerInfo {
            crate::api::WatchOnlyBannerInfo {
                banner_type: self.banner_type.cst_decode(),
                title: self.title.cst_decode(),
                subtitle: self.subtitle.cst_decode(),
                icon: self.icon.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::WatchOnlyCapabilitiesInfo> for wire_cst_watch_only_capabilities_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::WatchOnlyCapabilitiesInfo {
            crate::api::WatchOnlyCapabilitiesInfo {
                can_view_incoming: self.can_view_incoming.cst_decode(),
                can_view_outgoing: self.can_view_outgoing.cst_decode(),
                can_spend: self.can_spend.cst_decode(),
                can_export_seed: self.can_export_seed.cst_decode(),
                can_generate_addresses: self.can_generate_addresses.cst_decode(),
                is_watch_only: self.is_watch_only.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::WitnessRefreshOutcome> for wire_cst_witness_refresh_outcome {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::WitnessRefreshOutcome {
            crate::api::WitnessRefreshOutcome {
                source: self.source.cst_decode(),
                sapling_requested: self.sapling_requested.cst_decode(),
                sapling_updated: self.sapling_updated.cst_decode(),
                sapling_missing: self.sapling_missing.cst_decode(),
                sapling_errors: self.sapling_errors.cst_decode(),
                orchard_requested: self.orchard_requested.cst_decode(),
                orchard_updated: self.orchard_updated.cst_decode(),
                orchard_missing: self.orchard_missing.cst_decode(),
                orchard_errors: self.orchard_errors.cst_decode(),
            }
        }
    }
    impl NewWithNullPtr for wire_cst_address_balance_info {
        fn new_with_null_ptr() -> Self {
            Self {
                address: core::ptr::null_mut(),
                balance: Default::default(),
                spendable: Default::default(),
                pending: Default::default(),
                key_id: core::ptr::null_mut(),
                address_id: Default::default(),
                label: core::ptr::null_mut(),
                created_at: Default::default(),
                color_tag: Default::default(),
                diversifier_index: Default::default(),
            }
        }
    }
    impl Default for wire_cst_address_balance_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_address_book_entry_ffi {
        fn new_with_null_ptr() -> Self {
            Self {
                id: Default::default(),
                wallet_id: core::ptr::null_mut(),
                address: core::ptr::null_mut(),
                label: core::ptr::null_mut(),
                notes: core::ptr::null_mut(),
                color_tag: Default::default(),
                is_favorite: Default::default(),
                created_at: Default::default(),
                updated_at: Default::default(),
                last_used_at: core::ptr::null_mut(),
                use_count: Default::default(),
            }
        }
    }
    impl Default for wire_cst_address_book_entry_ffi {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_address_info {
        fn new_with_null_ptr() -> Self {
            Self {
                address: core::ptr::null_mut(),
                diversifier_index: Default::default(),
                label: core::ptr::null_mut(),
                created_at: Default::default(),
                color_tag: Default::default(),
            }
        }
    }
    impl Default for wire_cst_address_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_background_sync_result {
        fn new_with_null_ptr() -> Self {
            Self {
                mode: core::ptr::null_mut(),
                blocks_synced: Default::default(),
                start_height: Default::default(),
                end_height: Default::default(),
                duration_secs: Default::default(),
                errors: core::ptr::null_mut(),
                new_balance: core::ptr::null_mut(),
                new_transactions: Default::default(),
            }
        }
    }
    impl Default for wire_cst_background_sync_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_balance {
        fn new_with_null_ptr() -> Self {
            Self {
                total: Default::default(),
                spendable: Default::default(),
                pending: Default::default(),
            }
        }
    }
    impl Default for wire_cst_balance {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_build_info {
        fn new_with_null_ptr() -> Self {
            Self {
                version: core::ptr::null_mut(),
                git_commit: core::ptr::null_mut(),
                build_date: core::ptr::null_mut(),
                rust_version: core::ptr::null_mut(),
                target_triple: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_build_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_checkpoint_info {
        fn new_with_null_ptr() -> Self {
            Self {
                height: Default::default(),
                timestamp: Default::default(),
            }
        }
    }
    impl Default for wire_cst_checkpoint_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_fee_info {
        fn new_with_null_ptr() -> Self {
            Self {
                default_fee: Default::default(),
                min_fee: Default::default(),
                max_fee: Default::default(),
                fee_per_output: Default::default(),
                memo_fee_multiplier: Default::default(),
            }
        }
    }
    impl Default for wire_cst_fee_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_key_address_info {
        fn new_with_null_ptr() -> Self {
            Self {
                key_id: Default::default(),
                address: core::ptr::null_mut(),
                diversifier_index: Default::default(),
                label: core::ptr::null_mut(),
                created_at: Default::default(),
                color_tag: Default::default(),
            }
        }
    }
    impl Default for wire_cst_key_address_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_key_export_info {
        fn new_with_null_ptr() -> Self {
            Self {
                key_id: Default::default(),
                sapling_viewing_key: core::ptr::null_mut(),
                orchard_viewing_key: core::ptr::null_mut(),
                sapling_spending_key: core::ptr::null_mut(),
                orchard_spending_key: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_key_export_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_key_group_info {
        fn new_with_null_ptr() -> Self {
            Self {
                id: Default::default(),
                label: core::ptr::null_mut(),
                key_type: Default::default(),
                spendable: Default::default(),
                has_sapling: Default::default(),
                has_orchard: Default::default(),
                birthday_height: Default::default(),
                created_at: Default::default(),
            }
        }
    }
    impl Default for wire_cst_key_group_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_lightd_endpoint {
        fn new_with_null_ptr() -> Self {
            Self {
                host: core::ptr::null_mut(),
                port: Default::default(),
                use_tls: Default::default(),
                tls_pin: core::ptr::null_mut(),
                label: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_lightd_endpoint {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_network_info {
        fn new_with_null_ptr() -> Self {
            Self {
                name: core::ptr::null_mut(),
                coin_type: Default::default(),
                rpc_port: Default::default(),
                default_birthday: Default::default(),
            }
        }
    }
    impl Default for wire_cst_network_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_test_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                latest_block_height: core::ptr::null_mut(),
                transport_mode: core::ptr::null_mut(),
                tls_enabled: Default::default(),
                tls_pin_matched: core::ptr::null_mut(),
                expected_pin: core::ptr::null_mut(),
                actual_pin: core::ptr::null_mut(),
                error_message: core::ptr::null_mut(),
                response_time_ms: Default::default(),
                server_version: core::ptr::null_mut(),
                chain_name: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_test_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_output {
        fn new_with_null_ptr() -> Self {
            Self {
                addr: core::ptr::null_mut(),
                amount: Default::default(),
                memo: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_output {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_pending_tx {
        fn new_with_null_ptr() -> Self {
            Self {
                id: core::ptr::null_mut(),
                outputs: core::ptr::null_mut(),
                total_amount: Default::default(),
                fee: Default::default(),
                change: Default::default(),
                input_total: Default::default(),
                num_inputs: Default::default(),
                expiry_height: Default::default(),
                created_at: Default::default(),
            }
        }
    }
    impl Default for wire_cst_pending_tx {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_seed_export_warnings {
        fn new_with_null_ptr() -> Self {
            Self {
                primary: core::ptr::null_mut(),
                secondary: core::ptr::null_mut(),
                backup_instructions: core::ptr::null_mut(),
                clipboard_warning: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_seed_export_warnings {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_signed_tx {
        fn new_with_null_ptr() -> Self {
            Self {
                txid: core::ptr::null_mut(),
                raw: core::ptr::null_mut(),
                size: Default::default(),
            }
        }
    }
    impl Default for wire_cst_signed_tx {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_sync_log_entry_ffi {
        fn new_with_null_ptr() -> Self {
            Self {
                timestamp: Default::default(),
                level: core::ptr::null_mut(),
                module: core::ptr::null_mut(),
                message: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_sync_log_entry_ffi {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_sync_status {
        fn new_with_null_ptr() -> Self {
            Self {
                local_height: Default::default(),
                target_height: Default::default(),
                percent: Default::default(),
                eta: core::ptr::null_mut(),
                stage: Default::default(),
                last_checkpoint: core::ptr::null_mut(),
                blocks_per_second: Default::default(),
                notes_decrypted: Default::default(),
                last_batch_ms: Default::default(),
            }
        }
    }
    impl Default for wire_cst_sync_status {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_tunnel_mode {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: TunnelModeKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_tunnel_mode {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_tx_info {
        fn new_with_null_ptr() -> Self {
            Self {
                txid: core::ptr::null_mut(),
                height: core::ptr::null_mut(),
                timestamp: Default::default(),
                amount: Default::default(),
                fee: Default::default(),
                memo: core::ptr::null_mut(),
                confirmed: Default::default(),
            }
        }
    }
    impl Default for wire_cst_tx_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_wallet_background_sync_result {
        fn new_with_null_ptr() -> Self {
            Self {
                wallet_id: core::ptr::null_mut(),
                mode: core::ptr::null_mut(),
                blocks_synced: Default::default(),
                start_height: Default::default(),
                end_height: Default::default(),
                duration_secs: Default::default(),
                errors: core::ptr::null_mut(),
                new_balance: core::ptr::null_mut(),
                new_transactions: Default::default(),
            }
        }
    }
    impl Default for wire_cst_wallet_background_sync_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_wallet_meta {
        fn new_with_null_ptr() -> Self {
            Self {
                id: core::ptr::null_mut(),
                name: core::ptr::null_mut(),
                created_at: Default::default(),
                watch_only: Default::default(),
                birthday_height: Default::default(),
                network_type: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_wallet_meta {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_watch_only_banner_info {
        fn new_with_null_ptr() -> Self {
            Self {
                banner_type: core::ptr::null_mut(),
                title: core::ptr::null_mut(),
                subtitle: core::ptr::null_mut(),
                icon: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_watch_only_banner_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_watch_only_capabilities_info {
        fn new_with_null_ptr() -> Self {
            Self {
                can_view_incoming: Default::default(),
                can_view_outgoing: Default::default(),
                can_spend: Default::default(),
                can_export_seed: Default::default(),
                can_generate_addresses: Default::default(),
                is_watch_only: Default::default(),
            }
        }
    }
    impl Default for wire_cst_watch_only_capabilities_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_witness_refresh_outcome {
        fn new_with_null_ptr() -> Self {
            Self {
                source: core::ptr::null_mut(),
                sapling_requested: Default::default(),
                sapling_updated: Default::default(),
                sapling_missing: Default::default(),
                sapling_errors: Default::default(),
                orchard_requested: Default::default(),
                orchard_updated: Default::default(),
                orchard_missing: Default::default(),
                orchard_errors: Default::default(),
            }
        }
    }
    impl Default for wire_cst_witness_refresh_outcome {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__acknowledge_seed_warning(port_: i64) {
        wire__crate__api__acknowledge_seed_warning_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__add_address_book_entry(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        address: *mut wire_cst_list_prim_u_8_strict,
        label: *mut wire_cst_list_prim_u_8_strict,
        notes: *mut wire_cst_list_prim_u_8_strict,
        color_tag: i32,
    ) {
        wire__crate__api__add_address_book_entry_impl(
            port_, wallet_id, address, label, notes, color_tag,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__address_exists_in_book(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        address: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__address_exists_in_book_impl(port_, wallet_id, address)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__are_seed_screenshots_blocked(
        port_: i64,
    ) {
        wire__crate__api__are_seed_screenshots_blocked_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__bootstrap_tunnel(
        port_: i64,
        mode: *mut wire_cst_tunnel_mode,
    ) {
        wire__crate__api__bootstrap_tunnel_impl(port_, mode)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__broadcast_tx(
        port_: i64,
        signed: *mut wire_cst_signed_tx,
    ) {
        wire__crate__api__broadcast_tx_impl(port_, signed)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__build_consolidation_tx(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        key_id: i64,
        target_address: *mut wire_cst_list_prim_u_8_strict,
        fee_opt: *mut u64,
    ) {
        wire__crate__api__build_consolidation_tx_impl(
            port_,
            wallet_id,
            key_id,
            target_address,
            fee_opt,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__build_sweep_tx(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        target_address: *mut wire_cst_list_prim_u_8_strict,
        fee_opt: *mut u64,
        key_ids_filter: *mut wire_cst_list_prim_i_64_strict,
        address_ids_filter: *mut wire_cst_list_prim_i_64_strict,
    ) {
        wire__crate__api__build_sweep_tx_impl(
            port_,
            wallet_id,
            target_address,
            fee_opt,
            key_ids_filter,
            address_ids_filter,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__build_tx(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        outputs: *mut wire_cst_list_output,
        fee_opt: *mut u64,
    ) {
        wire__crate__api__build_tx_impl(port_, wallet_id, outputs, fee_opt)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__build_tx_filtered(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        outputs: *mut wire_cst_list_output,
        fee_opt: *mut u64,
        key_ids_filter: *mut wire_cst_list_prim_i_64_strict,
        address_ids_filter: *mut wire_cst_list_prim_i_64_strict,
    ) {
        wire__crate__api__build_tx_filtered_impl(
            port_,
            wallet_id,
            outputs,
            fee_opt,
            key_ids_filter,
            address_ids_filter,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__build_tx_for_key(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        key_id: i64,
        outputs: *mut wire_cst_list_output,
        fee_opt: *mut u64,
    ) {
        wire__crate__api__build_tx_for_key_impl(port_, wallet_id, key_id, outputs, fee_opt)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__cancel_seed_export(port_: i64) {
        wire__crate__api__cancel_seed_export_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__cancel_sync(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__cancel_sync_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__change_app_passphrase(
        port_: i64,
        current_passphrase: *mut wire_cst_list_prim_u_8_strict,
        new_passphrase: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__change_app_passphrase_impl(port_, current_passphrase, new_passphrase)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__change_app_passphrase_with_cached(
        port_: i64,
        new_passphrase: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__change_app_passphrase_with_cached_impl(port_, new_passphrase)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__clear_duress_passphrase(port_: i64) {
        wire__crate__api__clear_duress_passphrase_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__clear_panic_pin(port_: i64) {
        wire__crate__api__clear_panic_pin_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__complete_seed_biometric(
        port_: i64,
        success: bool,
    ) {
        wire__crate__api__complete_seed_biometric_impl(port_, success)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__create_wallet(
        port_: i64,
        name: *mut wire_cst_list_prim_u_8_strict,
        _entropy_len: *mut u32,
        birthday_opt: *mut u32,
    ) {
        wire__crate__api__create_wallet_impl(port_, name, _entropy_len, birthday_opt)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__current_receive_address(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__current_receive_address_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__delete_address_book_entry(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        id: i64,
    ) {
        wire__crate__api__delete_address_book_entry_impl(port_, wallet_id, id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__delete_wallet(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__delete_wallet_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__estimate_fee(
        port_: i64,
        num_outputs: usize,
        has_memo: bool,
        fee_policy: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__estimate_fee_impl(port_, num_outputs, has_memo, fee_policy)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__exit_decoy_mode(port_: i64) {
        wire__crate__api__exit_decoy_mode_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__export_ivk(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__export_ivk_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__export_ivk_secure(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__export_ivk_secure_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__export_key_group_keys(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        key_id: i64,
    ) {
        wire__crate__api__export_key_group_keys_impl(port_, wallet_id, key_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__export_orchard_ivk(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__export_orchard_ivk_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__export_orchard_viewing_key(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__export_orchard_viewing_key_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__export_seed(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__export_seed_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__export_seed_with_cached_passphrase(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__export_seed_with_cached_passphrase_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__export_seed_with_passphrase(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        passphrase: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__export_seed_with_passphrase_impl(port_, wallet_id, passphrase)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__fetch_transaction_memo(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        txid: *mut wire_cst_list_prim_u_8_strict,
        output_index: *mut u32,
    ) {
        wire__crate__api__fetch_transaction_memo_impl(port_, wallet_id, txid, output_index)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__format_amount(
        port_: i64,
        arrrtoshis: u64,
    ) {
        wire__crate__api__format_amount_impl(port_, arrrtoshis)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__generate_address_for_key(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        key_id: i64,
        use_orchard: bool,
    ) {
        wire__crate__api__generate_address_for_key_impl(port_, wallet_id, key_id, use_orchard)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__generate_mnemonic(
        port_: i64,
        word_count: *mut u32,
    ) {
        wire__crate__api__generate_mnemonic_impl(port_, word_count)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_active_wallet(port_: i64) {
        wire__crate__api__get_active_wallet_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_address_book_count(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__get_address_book_count_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_address_book_entry(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        id: i64,
    ) {
        wire__crate__api__get_address_book_entry_impl(port_, wallet_id, id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_address_book_entry_by_address(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        address: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__get_address_book_entry_by_address_impl(port_, wallet_id, address)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_address_book_favorites(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__get_address_book_favorites_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_auto_consolidation_candidate_count(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__get_auto_consolidation_candidate_count_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_auto_consolidation_enabled(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__get_auto_consolidation_enabled_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_auto_consolidation_threshold(
        port_: i64,
    ) {
        wire__crate__api__get_auto_consolidation_threshold_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_balance(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__get_balance_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_build_info(port_: i64) {
        wire__crate__api__get_build_info_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_checkpoint_details(
        port_: i64,
        _wallet_id: *mut wire_cst_list_prim_u_8_strict,
        height: u32,
    ) {
        wire__crate__api__get_checkpoint_details_impl(port_, _wallet_id, height)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_duress_passphrase_hash(
        port_: i64,
    ) {
        wire__crate__api__get_duress_passphrase_hash_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_fee_info(port_: i64) {
        wire__crate__api__get_fee_info_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_ivk_clipboard_remaining(
        port_: i64,
    ) {
        wire__crate__api__get_ivk_clipboard_remaining_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_label_for_address(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        address: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__get_label_for_address_impl(port_, wallet_id, address)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_last_checkpoint(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__get_last_checkpoint_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_lightd_endpoint(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__get_lightd_endpoint_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_lightd_endpoint_config(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__get_lightd_endpoint_config_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_network_info(port_: i64) {
        wire__crate__api__get_network_info_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_recently_used_addresses(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        limit: u32,
    ) {
        wire__crate__api__get_recently_used_addresses_impl(port_, wallet_id, limit)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_recommended_background_sync_mode(
        port_: i64,
        _wallet_id: *mut wire_cst_list_prim_u_8_strict,
        minutes_since_last: u32,
    ) {
        wire__crate__api__get_recommended_background_sync_mode_impl(
            port_,
            _wallet_id,
            minutes_since_last,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_seed_clipboard_remaining(
        port_: i64,
    ) {
        wire__crate__api__get_seed_clipboard_remaining_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_seed_export_state(port_: i64) {
        wire__crate__api__get_seed_export_state_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_seed_export_warnings(port_: i64) {
        wire__crate__api__get_seed_export_warnings_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_sync_logs(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        limit: *mut u32,
    ) {
        wire__crate__api__get_sync_logs_impl(port_, wallet_id, limit)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_tor_status(port_: i64) {
        wire__crate__api__get_tor_status_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_tunnel(port_: i64) {
        wire__crate__api__get_tunnel_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_vault_mode(port_: i64) {
        wire__crate__api__get_vault_mode_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_watch_only_banner(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__get_watch_only_banner_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__get_watch_only_capabilities(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__get_watch_only_capabilities_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__has_app_passphrase(port_: i64) {
        wire__crate__api__has_app_passphrase_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__has_duress_passphrase(port_: i64) {
        wire__crate__api__has_duress_passphrase_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__has_panic_pin(port_: i64) {
        wire__crate__api__has_panic_pin_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__import_ivk(
        port_: i64,
        name: *mut wire_cst_list_prim_u_8_strict,
        sapling_ivk: *mut wire_cst_list_prim_u_8_strict,
        orchard_ivk: *mut wire_cst_list_prim_u_8_strict,
        birthday: u32,
    ) {
        wire__crate__api__import_ivk_impl(port_, name, sapling_ivk, orchard_ivk, birthday)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__import_ivk_as_watch_only(
        port_: i64,
        name: *mut wire_cst_list_prim_u_8_strict,
        ivk: *mut wire_cst_list_prim_u_8_strict,
        birthday_height: u32,
    ) {
        wire__crate__api__import_ivk_as_watch_only_impl(port_, name, ivk, birthday_height)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__import_spending_key(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        sapling_key: *mut wire_cst_list_prim_u_8_strict,
        orchard_key: *mut wire_cst_list_prim_u_8_strict,
        label: *mut wire_cst_list_prim_u_8_strict,
        birthday_height: u32,
    ) {
        wire__crate__api__import_spending_key_impl(
            port_,
            wallet_id,
            sapling_key,
            orchard_key,
            label,
            birthday_height,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__is_background_sync_needed(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__is_background_sync_needed_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__is_decoy_mode(port_: i64) {
        wire__crate__api__is_decoy_mode_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__is_sync_running(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__is_sync_running_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__label_address(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        addr: *mut wire_cst_list_prim_u_8_strict,
        label: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__label_address_impl(port_, wallet_id, addr, label)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__lightd_endpoint_default(port_: i64) {
        wire__crate__api__lightd_endpoint_default_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__lightd_endpoint_display_string(
        port_: i64,
        that: *mut wire_cst_lightd_endpoint,
    ) {
        wire__crate__api__lightd_endpoint_display_string_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__lightd_endpoint_url(
        port_: i64,
        that: *mut wire_cst_lightd_endpoint,
    ) {
        wire__crate__api__lightd_endpoint_url_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__list_address_balances(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        key_id: *mut i64,
    ) {
        wire__crate__api__list_address_balances_impl(port_, wallet_id, key_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__list_address_book(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__list_address_book_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__list_addresses(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__list_addresses_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__list_addresses_for_key(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        key_id: i64,
    ) {
        wire__crate__api__list_addresses_for_key_impl(port_, wallet_id, key_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__list_key_groups(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__list_key_groups_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__list_transactions(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        limit: *mut u32,
    ) {
        wire__crate__api__list_transactions_impl(port_, wallet_id, limit)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__list_wallets(port_: i64) {
        wire__crate__api__list_wallets_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__mark_address_used(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        address: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__mark_address_used_impl(port_, wallet_id, address)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__next_receive_address(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__next_receive_address_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__parse_amount(
        port_: i64,
        arrr: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__parse_amount_impl(port_, arrr)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__rename_wallet(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        new_name: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__rename_wallet_impl(port_, wallet_id, new_name)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__rescan(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        from_height: u32,
    ) {
        wire__crate__api__rescan_impl(port_, wallet_id, from_height)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__reseal_db_keys_for_biometrics(
        port_: i64,
    ) {
        wire__crate__api__reseal_db_keys_for_biometrics_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__restore_wallet(
        port_: i64,
        name: *mut wire_cst_list_prim_u_8_strict,
        mnemonic: *mut wire_cst_list_prim_u_8_strict,
        passphrase_opt: *mut wire_cst_list_prim_u_8_strict,
        birthday_opt: *mut u32,
    ) {
        wire__crate__api__restore_wallet_impl(port_, name, mnemonic, passphrase_opt, birthday_opt)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__rotate_tor_exit(port_: i64) {
        wire__crate__api__rotate_tor_exit_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__search_address_book(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        query: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__search_address_book_impl(port_, wallet_id, query)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__set_address_color_tag(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        addr: *mut wire_cst_list_prim_u_8_strict,
        color_tag: i32,
    ) {
        wire__crate__api__set_address_color_tag_impl(port_, wallet_id, addr, color_tag)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__set_app_passphrase(
        port_: i64,
        passphrase: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__set_app_passphrase_impl(port_, passphrase)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__set_auto_consolidation_enabled(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        enabled: bool,
    ) {
        wire__crate__api__set_auto_consolidation_enabled_impl(port_, wallet_id, enabled)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__set_decoy_wallet_name(
        port_: i64,
        name: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__set_decoy_wallet_name_impl(port_, name)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__set_duress_passphrase(
        port_: i64,
        custom_passphrase: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__set_duress_passphrase_impl(port_, custom_passphrase)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__set_lightd_endpoint(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        url: *mut wire_cst_list_prim_u_8_strict,
        tls_pin_opt: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__set_lightd_endpoint_impl(port_, wallet_id, url, tls_pin_opt)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__set_panic_pin(
        port_: i64,
        pin: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__set_panic_pin_impl(port_, pin)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__set_tor_bridge_settings(
        port_: i64,
        use_bridges: bool,
        fallback_to_bridges: bool,
        transport: *mut wire_cst_list_prim_u_8_strict,
        bridge_lines: *mut wire_cst_list_String,
        transport_path: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__set_tor_bridge_settings_impl(
            port_,
            use_bridges,
            fallback_to_bridges,
            transport,
            bridge_lines,
            transport_path,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__set_tunnel(
        port_: i64,
        mode: *mut wire_cst_tunnel_mode,
    ) {
        wire__crate__api__set_tunnel_impl(port_, mode)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__set_wallet_birthday_height(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        birthday_height: u32,
    ) {
        wire__crate__api__set_wallet_birthday_height_impl(port_, wallet_id, birthday_height)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__shutdown_transport(port_: i64) {
        wire__crate__api__shutdown_transport_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__sign_tx(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        pending: *mut wire_cst_pending_tx,
    ) {
        wire__crate__api__sign_tx_impl(port_, wallet_id, pending)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__sign_tx_filtered(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        pending: *mut wire_cst_pending_tx,
        key_ids_filter: *mut wire_cst_list_prim_i_64_strict,
        address_ids_filter: *mut wire_cst_list_prim_i_64_strict,
    ) {
        wire__crate__api__sign_tx_filtered_impl(
            port_,
            wallet_id,
            pending,
            key_ids_filter,
            address_ids_filter,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__sign_tx_for_key(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        pending: *mut wire_cst_pending_tx,
        key_id: i64,
    ) {
        wire__crate__api__sign_tx_for_key_impl(port_, wallet_id, pending, key_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__skip_seed_biometric(port_: i64) {
        wire__crate__api__skip_seed_biometric_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__start_background_sync(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        mode: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__start_background_sync_impl(port_, wallet_id, mode)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__start_background_sync_round_robin(
        port_: i64,
        mode: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__start_background_sync_round_robin_impl(port_, mode)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__start_seed_export(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__start_seed_export_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__start_sync(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        mode: i32,
    ) {
        wire__crate__api__start_sync_impl(port_, wallet_id, mode)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__switch_wallet(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__switch_wallet_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__sync_status(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__sync_status_impl(port_, wallet_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__test_node(
        port_: i64,
        url: *mut wire_cst_list_prim_u_8_strict,
        tls_pin: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__test_node_impl(port_, url, tls_pin)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__toggle_address_book_favorite(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        id: i64,
    ) {
        wire__crate__api__toggle_address_book_favorite_impl(port_, wallet_id, id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__unlock_app(
        port_: i64,
        passphrase: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__unlock_app_impl(port_, passphrase)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__update_address_book_entry(
        port_: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        id: i64,
        label: *mut wire_cst_list_prim_u_8_strict,
        notes: *mut wire_cst_list_prim_u_8_strict,
        color_tag: *mut i32,
        is_favorite: *mut bool,
    ) {
        wire__crate__api__update_address_book_entry_impl(
            port_,
            wallet_id,
            id,
            label,
            notes,
            color_tag,
            is_favorite,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__validate_mnemonic(
        port_: i64,
        mnemonic: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__validate_mnemonic_impl(port_, mnemonic)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__verify_app_passphrase(
        port_: i64,
        passphrase: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__verify_app_passphrase_impl(port_, passphrase)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__verify_duress_passphrase(
        port_: i64,
        passphrase: *mut wire_cst_list_prim_u_8_strict,
        hash: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__verify_duress_passphrase_impl(port_, passphrase, hash)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__verify_panic_pin(
        port_: i64,
        pin: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__verify_panic_pin_impl(port_, pin)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__wallet_registry_exists(port_: i64) {
        wire__crate__api__wallet_registry_exists_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_wire__crate__api__witness_refresh_outcome_default(
        port_: i64,
    ) {
        wire__crate__api__witness_refresh_outcome_default_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_box_autoadd_address_book_color_tag(
        value: i32,
    ) -> *mut i32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_box_autoadd_address_book_entry_ffi(
    ) -> *mut wire_cst_address_book_entry_ffi {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_address_book_entry_ffi::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_box_autoadd_bool(value: bool) -> *mut bool {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_box_autoadd_checkpoint_info(
    ) -> *mut wire_cst_checkpoint_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_checkpoint_info::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_box_autoadd_i_64(value: i64) -> *mut i64 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_box_autoadd_lightd_endpoint(
    ) -> *mut wire_cst_lightd_endpoint {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_lightd_endpoint::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_box_autoadd_pending_tx(
    ) -> *mut wire_cst_pending_tx {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_pending_tx::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_box_autoadd_signed_tx() -> *mut wire_cst_signed_tx
    {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_signed_tx::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_box_autoadd_tunnel_mode(
    ) -> *mut wire_cst_tunnel_mode {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_tunnel_mode::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_box_autoadd_u_32(value: u32) -> *mut u32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_box_autoadd_u_64(value: u64) -> *mut u64 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_box_autoadd_watch_only_banner_info(
    ) -> *mut wire_cst_watch_only_banner_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_watch_only_banner_info::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_list_String(
        len: i32,
    ) -> *mut wire_cst_list_String {
        let wrap = wire_cst_list_String {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <*mut wire_cst_list_prim_u_8_strict>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_list_address_balance_info(
        len: i32,
    ) -> *mut wire_cst_list_address_balance_info {
        let wrap = wire_cst_list_address_balance_info {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_address_balance_info>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_list_address_book_entry_ffi(
        len: i32,
    ) -> *mut wire_cst_list_address_book_entry_ffi {
        let wrap = wire_cst_list_address_book_entry_ffi {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_address_book_entry_ffi>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_list_address_info(
        len: i32,
    ) -> *mut wire_cst_list_address_info {
        let wrap = wire_cst_list_address_info {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_address_info>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_list_key_address_info(
        len: i32,
    ) -> *mut wire_cst_list_key_address_info {
        let wrap = wire_cst_list_key_address_info {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_key_address_info>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_list_key_group_info(
        len: i32,
    ) -> *mut wire_cst_list_key_group_info {
        let wrap = wire_cst_list_key_group_info {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_key_group_info>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_list_output(
        len: i32,
    ) -> *mut wire_cst_list_output {
        let wrap = wire_cst_list_output {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_output>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_list_prim_i_64_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_i_64_strict {
        let ans = wire_cst_list_prim_i_64_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_strict {
        let ans = wire_cst_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_list_sync_log_entry_ffi(
        len: i32,
    ) -> *mut wire_cst_list_sync_log_entry_ffi {
        let wrap = wire_cst_list_sync_log_entry_ffi {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_sync_log_entry_ffi>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_list_tx_info(
        len: i32,
    ) -> *mut wire_cst_list_tx_info {
        let wrap = wire_cst_list_tx_info {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_tx_info>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_pirate_wallet_cst_new_list_wallet_meta(
        len: i32,
    ) -> *mut wire_cst_list_wallet_meta {
        let wrap = wire_cst_list_wallet_meta {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_wallet_meta>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_address_balance_info {
        address: *mut wire_cst_list_prim_u_8_strict,
        balance: u64,
        spendable: u64,
        pending: u64,
        key_id: *mut i64,
        address_id: i64,
        label: *mut wire_cst_list_prim_u_8_strict,
        created_at: i64,
        color_tag: i32,
        diversifier_index: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_address_book_entry_ffi {
        id: i64,
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        address: *mut wire_cst_list_prim_u_8_strict,
        label: *mut wire_cst_list_prim_u_8_strict,
        notes: *mut wire_cst_list_prim_u_8_strict,
        color_tag: i32,
        is_favorite: bool,
        created_at: i64,
        updated_at: i64,
        last_used_at: *mut i64,
        use_count: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_address_info {
        address: *mut wire_cst_list_prim_u_8_strict,
        diversifier_index: u32,
        label: *mut wire_cst_list_prim_u_8_strict,
        created_at: i64,
        color_tag: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_background_sync_result {
        mode: *mut wire_cst_list_prim_u_8_strict,
        blocks_synced: u64,
        start_height: u64,
        end_height: u64,
        duration_secs: u64,
        errors: *mut wire_cst_list_String,
        new_balance: *mut u64,
        new_transactions: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_balance {
        total: u64,
        spendable: u64,
        pending: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_build_info {
        version: *mut wire_cst_list_prim_u_8_strict,
        git_commit: *mut wire_cst_list_prim_u_8_strict,
        build_date: *mut wire_cst_list_prim_u_8_strict,
        rust_version: *mut wire_cst_list_prim_u_8_strict,
        target_triple: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_checkpoint_info {
        height: u32,
        timestamp: i64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_fee_info {
        default_fee: u64,
        min_fee: u64,
        max_fee: u64,
        fee_per_output: u64,
        memo_fee_multiplier: f64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_key_address_info {
        key_id: i64,
        address: *mut wire_cst_list_prim_u_8_strict,
        diversifier_index: u32,
        label: *mut wire_cst_list_prim_u_8_strict,
        created_at: i64,
        color_tag: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_key_export_info {
        key_id: i64,
        sapling_viewing_key: *mut wire_cst_list_prim_u_8_strict,
        orchard_viewing_key: *mut wire_cst_list_prim_u_8_strict,
        sapling_spending_key: *mut wire_cst_list_prim_u_8_strict,
        orchard_spending_key: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_key_group_info {
        id: i64,
        label: *mut wire_cst_list_prim_u_8_strict,
        key_type: i32,
        spendable: bool,
        has_sapling: bool,
        has_orchard: bool,
        birthday_height: i64,
        created_at: i64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_lightd_endpoint {
        host: *mut wire_cst_list_prim_u_8_strict,
        port: u16,
        use_tls: bool,
        tls_pin: *mut wire_cst_list_prim_u_8_strict,
        label: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_String {
        ptr: *mut *mut wire_cst_list_prim_u_8_strict,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_address_balance_info {
        ptr: *mut wire_cst_address_balance_info,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_address_book_entry_ffi {
        ptr: *mut wire_cst_address_book_entry_ffi,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_address_info {
        ptr: *mut wire_cst_address_info,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_key_address_info {
        ptr: *mut wire_cst_key_address_info,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_key_group_info {
        ptr: *mut wire_cst_key_group_info,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_output {
        ptr: *mut wire_cst_output,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_i_64_strict {
        ptr: *mut i64,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_strict {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_sync_log_entry_ffi {
        ptr: *mut wire_cst_sync_log_entry_ffi,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_tx_info {
        ptr: *mut wire_cst_tx_info,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_wallet_meta {
        ptr: *mut wire_cst_wallet_meta,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_network_info {
        name: *mut wire_cst_list_prim_u_8_strict,
        coin_type: u32,
        rpc_port: u16,
        default_birthday: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_test_result {
        success: bool,
        latest_block_height: *mut u64,
        transport_mode: *mut wire_cst_list_prim_u_8_strict,
        tls_enabled: bool,
        tls_pin_matched: *mut bool,
        expected_pin: *mut wire_cst_list_prim_u_8_strict,
        actual_pin: *mut wire_cst_list_prim_u_8_strict,
        error_message: *mut wire_cst_list_prim_u_8_strict,
        response_time_ms: u64,
        server_version: *mut wire_cst_list_prim_u_8_strict,
        chain_name: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_output {
        addr: *mut wire_cst_list_prim_u_8_strict,
        amount: u64,
        memo: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_pending_tx {
        id: *mut wire_cst_list_prim_u_8_strict,
        outputs: *mut wire_cst_list_output,
        total_amount: u64,
        fee: u64,
        change: u64,
        input_total: u64,
        num_inputs: u32,
        expiry_height: u32,
        created_at: i64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_seed_export_warnings {
        primary: *mut wire_cst_list_prim_u_8_strict,
        secondary: *mut wire_cst_list_prim_u_8_strict,
        backup_instructions: *mut wire_cst_list_prim_u_8_strict,
        clipboard_warning: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_signed_tx {
        txid: *mut wire_cst_list_prim_u_8_strict,
        raw: *mut wire_cst_list_prim_u_8_strict,
        size: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_sync_log_entry_ffi {
        timestamp: i64,
        level: *mut wire_cst_list_prim_u_8_strict,
        module: *mut wire_cst_list_prim_u_8_strict,
        message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_sync_status {
        local_height: u64,
        target_height: u64,
        percent: f64,
        eta: *mut u64,
        stage: i32,
        last_checkpoint: *mut u64,
        blocks_per_second: f64,
        notes_decrypted: u64,
        last_batch_ms: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_tunnel_mode {
        tag: i32,
        kind: TunnelModeKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union TunnelModeKind {
        Socks5: wire_cst_TunnelMode_Socks5,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_TunnelMode_Socks5 {
        url: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_tx_info {
        txid: *mut wire_cst_list_prim_u_8_strict,
        height: *mut u32,
        timestamp: i64,
        amount: i64,
        fee: u64,
        memo: *mut wire_cst_list_prim_u_8_strict,
        confirmed: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_wallet_background_sync_result {
        wallet_id: *mut wire_cst_list_prim_u_8_strict,
        mode: *mut wire_cst_list_prim_u_8_strict,
        blocks_synced: u64,
        start_height: u64,
        end_height: u64,
        duration_secs: u64,
        errors: *mut wire_cst_list_String,
        new_balance: *mut u64,
        new_transactions: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_wallet_meta {
        id: *mut wire_cst_list_prim_u_8_strict,
        name: *mut wire_cst_list_prim_u_8_strict,
        created_at: i64,
        watch_only: bool,
        birthday_height: u32,
        network_type: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_watch_only_banner_info {
        banner_type: *mut wire_cst_list_prim_u_8_strict,
        title: *mut wire_cst_list_prim_u_8_strict,
        subtitle: *mut wire_cst_list_prim_u_8_strict,
        icon: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_watch_only_capabilities_info {
        can_view_incoming: bool,
        can_view_outgoing: bool,
        can_spend: bool,
        can_export_seed: bool,
        can_generate_addresses: bool,
        is_watch_only: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_witness_refresh_outcome {
        source: *mut wire_cst_list_prim_u_8_strict,
        sapling_requested: usize,
        sapling_updated: usize,
        sapling_missing: usize,
        sapling_errors: usize,
        orchard_requested: usize,
        orchard_updated: usize,
        orchard_missing: usize,
        orchard_errors: usize,
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();

    // Section: dart2rust

    impl CstDecode<flutter_rust_bridge::for_generated::anyhow::Error> for String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::for_generated::anyhow::Error {
            unimplemented!()
        }
    }
    impl CstDecode<String> for String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            self
        }
    }
    impl CstDecode<crate::models::AddressBalanceInfo>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::AddressBalanceInfo {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                10,
                "Expected 10 elements, got {}",
                self_.length()
            );
            crate::models::AddressBalanceInfo {
                address: self_.get(0).cst_decode(),
                balance: self_.get(1).cst_decode(),
                spendable: self_.get(2).cst_decode(),
                pending: self_.get(3).cst_decode(),
                key_id: self_.get(4).cst_decode(),
                address_id: self_.get(5).cst_decode(),
                label: self_.get(6).cst_decode(),
                created_at: self_.get(7).cst_decode(),
                color_tag: self_.get(8).cst_decode(),
                diversifier_index: self_.get(9).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::AddressBookEntryFfi>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::AddressBookEntryFfi {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                11,
                "Expected 11 elements, got {}",
                self_.length()
            );
            crate::models::AddressBookEntryFfi {
                id: self_.get(0).cst_decode(),
                wallet_id: self_.get(1).cst_decode(),
                address: self_.get(2).cst_decode(),
                label: self_.get(3).cst_decode(),
                notes: self_.get(4).cst_decode(),
                color_tag: self_.get(5).cst_decode(),
                is_favorite: self_.get(6).cst_decode(),
                created_at: self_.get(7).cst_decode(),
                updated_at: self_.get(8).cst_decode(),
                last_used_at: self_.get(9).cst_decode(),
                use_count: self_.get(10).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::AddressInfo>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::AddressInfo {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                5,
                "Expected 5 elements, got {}",
                self_.length()
            );
            crate::models::AddressInfo {
                address: self_.get(0).cst_decode(),
                diversifier_index: self_.get(1).cst_decode(),
                label: self_.get(2).cst_decode(),
                created_at: self_.get(3).cst_decode(),
                color_tag: self_.get(4).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::BackgroundSyncResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::BackgroundSyncResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                8,
                "Expected 8 elements, got {}",
                self_.length()
            );
            crate::models::BackgroundSyncResult {
                mode: self_.get(0).cst_decode(),
                blocks_synced: self_.get(1).cst_decode(),
                start_height: self_.get(2).cst_decode(),
                end_height: self_.get(3).cst_decode(),
                duration_secs: self_.get(4).cst_decode(),
                errors: self_.get(5).cst_decode(),
                new_balance: self_.get(6).cst_decode(),
                new_transactions: self_.get(7).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::Balance>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::Balance {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            crate::models::Balance {
                total: self_.get(0).cst_decode(),
                spendable: self_.get(1).cst_decode(),
                pending: self_.get(2).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::BuildInfo>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::BuildInfo {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                5,
                "Expected 5 elements, got {}",
                self_.length()
            );
            crate::models::BuildInfo {
                version: self_.get(0).cst_decode(),
                git_commit: self_.get(1).cst_decode(),
                build_date: self_.get(2).cst_decode(),
                rust_version: self_.get(3).cst_decode(),
                target_triple: self_.get(4).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::CheckpointInfo>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::CheckpointInfo {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            crate::api::CheckpointInfo {
                height: self_.get(0).cst_decode(),
                timestamp: self_.get(1).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::FeeInfo> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::FeeInfo {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                5,
                "Expected 5 elements, got {}",
                self_.length()
            );
            crate::api::FeeInfo {
                default_fee: self_.get(0).cst_decode(),
                min_fee: self_.get(1).cst_decode(),
                max_fee: self_.get(2).cst_decode(),
                fee_per_output: self_.get(3).cst_decode(),
                memo_fee_multiplier: self_.get(4).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::KeyAddressInfo>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::KeyAddressInfo {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                6,
                "Expected 6 elements, got {}",
                self_.length()
            );
            crate::models::KeyAddressInfo {
                key_id: self_.get(0).cst_decode(),
                address: self_.get(1).cst_decode(),
                diversifier_index: self_.get(2).cst_decode(),
                label: self_.get(3).cst_decode(),
                created_at: self_.get(4).cst_decode(),
                color_tag: self_.get(5).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::KeyExportInfo>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::KeyExportInfo {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                5,
                "Expected 5 elements, got {}",
                self_.length()
            );
            crate::models::KeyExportInfo {
                key_id: self_.get(0).cst_decode(),
                sapling_viewing_key: self_.get(1).cst_decode(),
                orchard_viewing_key: self_.get(2).cst_decode(),
                sapling_spending_key: self_.get(3).cst_decode(),
                orchard_spending_key: self_.get(4).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::KeyGroupInfo>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::KeyGroupInfo {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                8,
                "Expected 8 elements, got {}",
                self_.length()
            );
            crate::models::KeyGroupInfo {
                id: self_.get(0).cst_decode(),
                label: self_.get(1).cst_decode(),
                key_type: self_.get(2).cst_decode(),
                spendable: self_.get(3).cst_decode(),
                has_sapling: self_.get(4).cst_decode(),
                has_orchard: self_.get(5).cst_decode(),
                birthday_height: self_.get(6).cst_decode(),
                created_at: self_.get(7).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::LightdEndpoint>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::LightdEndpoint {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                5,
                "Expected 5 elements, got {}",
                self_.length()
            );
            crate::api::LightdEndpoint {
                host: self_.get(0).cst_decode(),
                port: self_.get(1).cst_decode(),
                use_tls: self_.get(2).cst_decode(),
                tls_pin: self_.get(3).cst_decode(),
                label: self_.get(4).cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<String>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<String> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::models::AddressBalanceInfo>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::AddressBalanceInfo> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::models::AddressBookEntryFfi>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::AddressBookEntryFfi> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::models::AddressInfo>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::AddressInfo> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::models::KeyAddressInfo>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::KeyAddressInfo> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::models::KeyGroupInfo>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::KeyGroupInfo> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::models::Output>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::Output> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<i64>> for Box<[i64]> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<i64> {
            self.into_vec()
        }
    }
    impl CstDecode<Vec<u8>> for Box<[u8]> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            self.into_vec()
        }
    }
    impl CstDecode<Vec<crate::models::SyncLogEntryFfi>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::SyncLogEntryFfi> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::models::TxInfo>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::TxInfo> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::models::WalletMeta>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::WalletMeta> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<crate::models::NetworkInfo>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::NetworkInfo {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::models::NetworkInfo {
                name: self_.get(0).cst_decode(),
                coin_type: self_.get(1).cst_decode(),
                rpc_port: self_.get(2).cst_decode(),
                default_birthday: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::NodeTestResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::NodeTestResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                11,
                "Expected 11 elements, got {}",
                self_.length()
            );
            crate::models::NodeTestResult {
                success: self_.get(0).cst_decode(),
                latest_block_height: self_.get(1).cst_decode(),
                transport_mode: self_.get(2).cst_decode(),
                tls_enabled: self_.get(3).cst_decode(),
                tls_pin_matched: self_.get(4).cst_decode(),
                expected_pin: self_.get(5).cst_decode(),
                actual_pin: self_.get(6).cst_decode(),
                error_message: self_.get(7).cst_decode(),
                response_time_ms: self_.get(8).cst_decode(),
                server_version: self_.get(9).cst_decode(),
                chain_name: self_.get(10).cst_decode(),
            }
        }
    }
    impl CstDecode<Option<String>> for Option<String> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Option<String> {
            self.map(CstDecode::cst_decode)
        }
    }
    impl CstDecode<Option<Vec<i64>>> for Option<Box<[i64]>> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Option<Vec<i64>> {
            self.map(CstDecode::cst_decode)
        }
    }
    impl CstDecode<crate::models::Output>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::Output {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            crate::models::Output {
                addr: self_.get(0).cst_decode(),
                amount: self_.get(1).cst_decode(),
                memo: self_.get(2).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::PendingTx>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::PendingTx {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                9,
                "Expected 9 elements, got {}",
                self_.length()
            );
            crate::models::PendingTx {
                id: self_.get(0).cst_decode(),
                outputs: self_.get(1).cst_decode(),
                total_amount: self_.get(2).cst_decode(),
                fee: self_.get(3).cst_decode(),
                change: self_.get(4).cst_decode(),
                input_total: self_.get(5).cst_decode(),
                num_inputs: self_.get(6).cst_decode(),
                expiry_height: self_.get(7).cst_decode(),
                created_at: self_.get(8).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::SeedExportWarnings>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::SeedExportWarnings {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::api::SeedExportWarnings {
                primary: self_.get(0).cst_decode(),
                secondary: self_.get(1).cst_decode(),
                backup_instructions: self_.get(2).cst_decode(),
                clipboard_warning: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::SignedTx>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::SignedTx {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            crate::models::SignedTx {
                txid: self_.get(0).cst_decode(),
                raw: self_.get(1).cst_decode(),
                size: self_.get(2).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::SyncLogEntryFfi>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::SyncLogEntryFfi {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::models::SyncLogEntryFfi {
                timestamp: self_.get(0).cst_decode(),
                level: self_.get(1).cst_decode(),
                module: self_.get(2).cst_decode(),
                message: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::SyncStatus>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::SyncStatus {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                9,
                "Expected 9 elements, got {}",
                self_.length()
            );
            crate::models::SyncStatus {
                local_height: self_.get(0).cst_decode(),
                target_height: self_.get(1).cst_decode(),
                percent: self_.get(2).cst_decode(),
                eta: self_.get(3).cst_decode(),
                stage: self_.get(4).cst_decode(),
                last_checkpoint: self_.get(5).cst_decode(),
                blocks_per_second: self_.get(6).cst_decode(),
                notes_decrypted: self_.get(7).cst_decode(),
                last_batch_ms: self_.get(8).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::TunnelMode>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::TunnelMode {
            let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
            match self_.get(0).unchecked_into_f64() as _ {
                0 => crate::models::TunnelMode::Tor,
                1 => crate::models::TunnelMode::I2p,
                2 => crate::models::TunnelMode::Socks5 {
                    url: self_.get(1).cst_decode(),
                },
                3 => crate::models::TunnelMode::Direct,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::models::TxInfo>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::TxInfo {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                7,
                "Expected 7 elements, got {}",
                self_.length()
            );
            crate::models::TxInfo {
                txid: self_.get(0).cst_decode(),
                height: self_.get(1).cst_decode(),
                timestamp: self_.get(2).cst_decode(),
                amount: self_.get(3).cst_decode(),
                fee: self_.get(4).cst_decode(),
                memo: self_.get(5).cst_decode(),
                confirmed: self_.get(6).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::WalletBackgroundSyncResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::WalletBackgroundSyncResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                9,
                "Expected 9 elements, got {}",
                self_.length()
            );
            crate::models::WalletBackgroundSyncResult {
                wallet_id: self_.get(0).cst_decode(),
                mode: self_.get(1).cst_decode(),
                blocks_synced: self_.get(2).cst_decode(),
                start_height: self_.get(3).cst_decode(),
                end_height: self_.get(4).cst_decode(),
                duration_secs: self_.get(5).cst_decode(),
                errors: self_.get(6).cst_decode(),
                new_balance: self_.get(7).cst_decode(),
                new_transactions: self_.get(8).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::WalletMeta>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::WalletMeta {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                6,
                "Expected 6 elements, got {}",
                self_.length()
            );
            crate::models::WalletMeta {
                id: self_.get(0).cst_decode(),
                name: self_.get(1).cst_decode(),
                created_at: self_.get(2).cst_decode(),
                watch_only: self_.get(3).cst_decode(),
                birthday_height: self_.get(4).cst_decode(),
                network_type: self_.get(5).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::WatchOnlyBannerInfo>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::WatchOnlyBannerInfo {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::api::WatchOnlyBannerInfo {
                banner_type: self_.get(0).cst_decode(),
                title: self_.get(1).cst_decode(),
                subtitle: self_.get(2).cst_decode(),
                icon: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::WatchOnlyCapabilitiesInfo>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::WatchOnlyCapabilitiesInfo {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                6,
                "Expected 6 elements, got {}",
                self_.length()
            );
            crate::api::WatchOnlyCapabilitiesInfo {
                can_view_incoming: self_.get(0).cst_decode(),
                can_view_outgoing: self_.get(1).cst_decode(),
                can_spend: self_.get(2).cst_decode(),
                can_export_seed: self_.get(3).cst_decode(),
                can_generate_addresses: self_.get(4).cst_decode(),
                is_watch_only: self_.get(5).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::WitnessRefreshOutcome>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::WitnessRefreshOutcome {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                9,
                "Expected 9 elements, got {}",
                self_.length()
            );
            crate::api::WitnessRefreshOutcome {
                source: self_.get(0).cst_decode(),
                sapling_requested: self_.get(1).cst_decode(),
                sapling_updated: self_.get(2).cst_decode(),
                sapling_missing: self_.get(3).cst_decode(),
                sapling_errors: self_.get(4).cst_decode(),
                orchard_requested: self_.get(5).cst_decode(),
                orchard_updated: self_.get(6).cst_decode(),
                orchard_missing: self_.get(7).cst_decode(),
                orchard_errors: self_.get(8).cst_decode(),
            }
        }
    }
    impl CstDecode<flutter_rust_bridge::for_generated::anyhow::Error>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::for_generated::anyhow::Error {
            unimplemented!()
        }
    }
    impl CstDecode<String> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            self.as_string().expect("non-UTF-8 string, or not a string")
        }
    }
    impl CstDecode<crate::models::AddressBookColorTag>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::AddressBookColorTag {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<bool> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> bool {
            self.is_truthy()
        }
    }
    impl CstDecode<f64> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> f64 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<i32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> i32 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<i64> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> i64 {
            ::std::convert::TryInto::<i64>::try_into(self).unwrap() as _
        }
    }
    impl CstDecode<crate::models::KeyTypeInfo>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::KeyTypeInfo {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<Vec<i64>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<i64> {
            let buf = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::BigInt64Array>()
                .unwrap();
            let buf = flutter_rust_bridge::for_generated::js_sys::Uint8Array::new(&buf.buffer());
            flutter_rust_bridge::for_generated::slice_from_byte_buffer(buf.to_vec()).into()
        }
    }
    impl CstDecode<Vec<u8>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Uint8Array>()
                .to_vec()
                .into()
        }
    }
    impl CstDecode<crate::models::SyncMode>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::SyncMode {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<crate::models::SyncStage>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::SyncStage {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<u16> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u16 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<u32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<u64> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u64 {
            ::std::convert::TryInto::<u64>::try_into(self).unwrap() as _
        }
    }
    impl CstDecode<u8> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u8 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<usize> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> usize {
            ::std::convert::TryInto::<u64>::try_into(self).unwrap() as _
        }
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__acknowledge_seed_warning(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__acknowledge_seed_warning_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__add_address_book_entry(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        address: String,
        label: String,
        notes: Option<String>,
        color_tag: i32,
    ) {
        wire__crate__api__add_address_book_entry_impl(
            port_, wallet_id, address, label, notes, color_tag,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__address_exists_in_book(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        address: String,
    ) {
        wire__crate__api__address_exists_in_book_impl(port_, wallet_id, address)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__are_seed_screenshots_blocked(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__are_seed_screenshots_blocked_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__bootstrap_tunnel(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        mode: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__bootstrap_tunnel_impl(port_, mode)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__broadcast_tx(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        signed: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__broadcast_tx_impl(port_, signed)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__build_consolidation_tx(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        key_id: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        target_address: String,
        fee_opt: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__build_consolidation_tx_impl(
            port_,
            wallet_id,
            key_id,
            target_address,
            fee_opt,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__build_sweep_tx(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        target_address: String,
        fee_opt: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        key_ids_filter: Option<Box<[i64]>>,
        address_ids_filter: Option<Box<[i64]>>,
    ) {
        wire__crate__api__build_sweep_tx_impl(
            port_,
            wallet_id,
            target_address,
            fee_opt,
            key_ids_filter,
            address_ids_filter,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__build_tx(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        outputs: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        fee_opt: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__build_tx_impl(port_, wallet_id, outputs, fee_opt)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__build_tx_filtered(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        outputs: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        fee_opt: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        key_ids_filter: Option<Box<[i64]>>,
        address_ids_filter: Option<Box<[i64]>>,
    ) {
        wire__crate__api__build_tx_filtered_impl(
            port_,
            wallet_id,
            outputs,
            fee_opt,
            key_ids_filter,
            address_ids_filter,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__build_tx_for_key(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        key_id: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        outputs: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        fee_opt: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__build_tx_for_key_impl(port_, wallet_id, key_id, outputs, fee_opt)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__cancel_seed_export(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__cancel_seed_export_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__cancel_sync(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__cancel_sync_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__change_app_passphrase(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        current_passphrase: String,
        new_passphrase: String,
    ) {
        wire__crate__api__change_app_passphrase_impl(port_, current_passphrase, new_passphrase)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__change_app_passphrase_with_cached(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        new_passphrase: String,
    ) {
        wire__crate__api__change_app_passphrase_with_cached_impl(port_, new_passphrase)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__clear_duress_passphrase(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__clear_duress_passphrase_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__clear_panic_pin(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__clear_panic_pin_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__complete_seed_biometric(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        success: bool,
    ) {
        wire__crate__api__complete_seed_biometric_impl(port_, success)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__create_wallet(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        name: String,
        _entropy_len: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        birthday_opt: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__create_wallet_impl(port_, name, _entropy_len, birthday_opt)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__current_receive_address(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__current_receive_address_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__delete_address_book_entry(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        id: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__delete_address_book_entry_impl(port_, wallet_id, id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__delete_wallet(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__delete_wallet_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__estimate_fee(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        num_outputs: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        has_memo: bool,
        fee_policy: Option<String>,
    ) {
        wire__crate__api__estimate_fee_impl(port_, num_outputs, has_memo, fee_policy)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__exit_decoy_mode(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__exit_decoy_mode_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__export_ivk(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__export_ivk_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__export_ivk_secure(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__export_ivk_secure_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__export_key_group_keys(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        key_id: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__export_key_group_keys_impl(port_, wallet_id, key_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__export_orchard_ivk(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__export_orchard_ivk_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__export_orchard_viewing_key(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__export_orchard_viewing_key_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__export_seed(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__export_seed_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__export_seed_with_cached_passphrase(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__export_seed_with_cached_passphrase_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__export_seed_with_passphrase(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        passphrase: String,
    ) {
        wire__crate__api__export_seed_with_passphrase_impl(port_, wallet_id, passphrase)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__fetch_transaction_memo(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        txid: String,
        output_index: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__fetch_transaction_memo_impl(port_, wallet_id, txid, output_index)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__format_amount(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        arrrtoshis: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__format_amount_impl(port_, arrrtoshis)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__generate_address_for_key(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        key_id: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        use_orchard: bool,
    ) {
        wire__crate__api__generate_address_for_key_impl(port_, wallet_id, key_id, use_orchard)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__generate_mnemonic(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        word_count: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__generate_mnemonic_impl(port_, word_count)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_active_wallet(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__get_active_wallet_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_address_book_count(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__get_address_book_count_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_address_book_entry(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        id: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__get_address_book_entry_impl(port_, wallet_id, id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_address_book_entry_by_address(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        address: String,
    ) {
        wire__crate__api__get_address_book_entry_by_address_impl(port_, wallet_id, address)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_address_book_favorites(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__get_address_book_favorites_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_auto_consolidation_candidate_count(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__get_auto_consolidation_candidate_count_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_auto_consolidation_enabled(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__get_auto_consolidation_enabled_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_auto_consolidation_threshold(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__get_auto_consolidation_threshold_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_balance(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__get_balance_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_build_info(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__get_build_info_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_checkpoint_details(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        _wallet_id: String,
        height: u32,
    ) {
        wire__crate__api__get_checkpoint_details_impl(port_, _wallet_id, height)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_duress_passphrase_hash(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__get_duress_passphrase_hash_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_fee_info(port_: flutter_rust_bridge::for_generated::MessagePort) {
        wire__crate__api__get_fee_info_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_ivk_clipboard_remaining(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__get_ivk_clipboard_remaining_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_label_for_address(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        address: String,
    ) {
        wire__crate__api__get_label_for_address_impl(port_, wallet_id, address)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_last_checkpoint(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__get_last_checkpoint_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_lightd_endpoint(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__get_lightd_endpoint_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_lightd_endpoint_config(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__get_lightd_endpoint_config_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_network_info(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__get_network_info_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_recently_used_addresses(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        limit: u32,
    ) {
        wire__crate__api__get_recently_used_addresses_impl(port_, wallet_id, limit)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_recommended_background_sync_mode(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        _wallet_id: String,
        minutes_since_last: u32,
    ) {
        wire__crate__api__get_recommended_background_sync_mode_impl(
            port_,
            _wallet_id,
            minutes_since_last,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_seed_clipboard_remaining(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__get_seed_clipboard_remaining_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_seed_export_state(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__get_seed_export_state_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_seed_export_warnings(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__get_seed_export_warnings_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_sync_logs(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        limit: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__get_sync_logs_impl(port_, wallet_id, limit)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_tor_status(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__get_tor_status_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_tunnel(port_: flutter_rust_bridge::for_generated::MessagePort) {
        wire__crate__api__get_tunnel_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_vault_mode(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__get_vault_mode_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_watch_only_banner(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__get_watch_only_banner_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_watch_only_capabilities(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__get_watch_only_capabilities_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__has_app_passphrase(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__has_app_passphrase_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__has_duress_passphrase(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__has_duress_passphrase_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__has_panic_pin(port_: flutter_rust_bridge::for_generated::MessagePort) {
        wire__crate__api__has_panic_pin_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__import_ivk(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        name: String,
        sapling_ivk: Option<String>,
        orchard_ivk: Option<String>,
        birthday: u32,
    ) {
        wire__crate__api__import_ivk_impl(port_, name, sapling_ivk, orchard_ivk, birthday)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__import_ivk_as_watch_only(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        name: String,
        ivk: String,
        birthday_height: u32,
    ) {
        wire__crate__api__import_ivk_as_watch_only_impl(port_, name, ivk, birthday_height)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__import_spending_key(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        sapling_key: Option<String>,
        orchard_key: Option<String>,
        label: Option<String>,
        birthday_height: u32,
    ) {
        wire__crate__api__import_spending_key_impl(
            port_,
            wallet_id,
            sapling_key,
            orchard_key,
            label,
            birthday_height,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__is_background_sync_needed(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__is_background_sync_needed_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__is_decoy_mode(port_: flutter_rust_bridge::for_generated::MessagePort) {
        wire__crate__api__is_decoy_mode_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__is_sync_running(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__is_sync_running_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__label_address(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        addr: String,
        label: String,
    ) {
        wire__crate__api__label_address_impl(port_, wallet_id, addr, label)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__lightd_endpoint_default(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__lightd_endpoint_default_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__lightd_endpoint_display_string(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__lightd_endpoint_display_string_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__lightd_endpoint_url(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__lightd_endpoint_url_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__list_address_balances(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        key_id: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__list_address_balances_impl(port_, wallet_id, key_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__list_address_book(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__list_address_book_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__list_addresses(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__list_addresses_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__list_addresses_for_key(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        key_id: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__list_addresses_for_key_impl(port_, wallet_id, key_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__list_key_groups(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__list_key_groups_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__list_transactions(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        limit: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__list_transactions_impl(port_, wallet_id, limit)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__list_wallets(port_: flutter_rust_bridge::for_generated::MessagePort) {
        wire__crate__api__list_wallets_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mark_address_used(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        address: String,
    ) {
        wire__crate__api__mark_address_used_impl(port_, wallet_id, address)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__next_receive_address(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__next_receive_address_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__parse_amount(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        arrr: String,
    ) {
        wire__crate__api__parse_amount_impl(port_, arrr)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__rename_wallet(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        new_name: String,
    ) {
        wire__crate__api__rename_wallet_impl(port_, wallet_id, new_name)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__rescan(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        from_height: u32,
    ) {
        wire__crate__api__rescan_impl(port_, wallet_id, from_height)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__reseal_db_keys_for_biometrics(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__reseal_db_keys_for_biometrics_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__restore_wallet(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        name: String,
        mnemonic: String,
        passphrase_opt: Option<String>,
        birthday_opt: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__restore_wallet_impl(port_, name, mnemonic, passphrase_opt, birthday_opt)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__rotate_tor_exit(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__rotate_tor_exit_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__search_address_book(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        query: String,
    ) {
        wire__crate__api__search_address_book_impl(port_, wallet_id, query)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__set_address_color_tag(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        addr: String,
        color_tag: i32,
    ) {
        wire__crate__api__set_address_color_tag_impl(port_, wallet_id, addr, color_tag)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__set_app_passphrase(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        passphrase: String,
    ) {
        wire__crate__api__set_app_passphrase_impl(port_, passphrase)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__set_auto_consolidation_enabled(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        enabled: bool,
    ) {
        wire__crate__api__set_auto_consolidation_enabled_impl(port_, wallet_id, enabled)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__set_decoy_wallet_name(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        name: String,
    ) {
        wire__crate__api__set_decoy_wallet_name_impl(port_, name)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__set_duress_passphrase(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        custom_passphrase: Option<String>,
    ) {
        wire__crate__api__set_duress_passphrase_impl(port_, custom_passphrase)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__set_lightd_endpoint(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        url: String,
        tls_pin_opt: Option<String>,
    ) {
        wire__crate__api__set_lightd_endpoint_impl(port_, wallet_id, url, tls_pin_opt)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__set_panic_pin(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        pin: String,
    ) {
        wire__crate__api__set_panic_pin_impl(port_, pin)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__set_tor_bridge_settings(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        use_bridges: bool,
        fallback_to_bridges: bool,
        transport: String,
        bridge_lines: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        transport_path: Option<String>,
    ) {
        wire__crate__api__set_tor_bridge_settings_impl(
            port_,
            use_bridges,
            fallback_to_bridges,
            transport,
            bridge_lines,
            transport_path,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__set_tunnel(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        mode: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__set_tunnel_impl(port_, mode)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__set_wallet_birthday_height(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        birthday_height: u32,
    ) {
        wire__crate__api__set_wallet_birthday_height_impl(port_, wallet_id, birthday_height)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__shutdown_transport(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__shutdown_transport_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sign_tx(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        pending: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__sign_tx_impl(port_, wallet_id, pending)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sign_tx_filtered(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        pending: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        key_ids_filter: Option<Box<[i64]>>,
        address_ids_filter: Option<Box<[i64]>>,
    ) {
        wire__crate__api__sign_tx_filtered_impl(
            port_,
            wallet_id,
            pending,
            key_ids_filter,
            address_ids_filter,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sign_tx_for_key(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        pending: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        key_id: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__sign_tx_for_key_impl(port_, wallet_id, pending, key_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__skip_seed_biometric(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__skip_seed_biometric_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__start_background_sync(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        mode: Option<String>,
    ) {
        wire__crate__api__start_background_sync_impl(port_, wallet_id, mode)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__start_background_sync_round_robin(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        mode: Option<String>,
    ) {
        wire__crate__api__start_background_sync_round_robin_impl(port_, mode)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__start_seed_export(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__start_seed_export_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__start_sync(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        mode: i32,
    ) {
        wire__crate__api__start_sync_impl(port_, wallet_id, mode)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__switch_wallet(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__switch_wallet_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sync_status(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
    ) {
        wire__crate__api__sync_status_impl(port_, wallet_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__test_node(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        url: String,
        tls_pin: Option<String>,
    ) {
        wire__crate__api__test_node_impl(port_, url, tls_pin)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__toggle_address_book_favorite(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        id: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__toggle_address_book_favorite_impl(port_, wallet_id, id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__unlock_app(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        passphrase: String,
    ) {
        wire__crate__api__unlock_app_impl(port_, passphrase)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__update_address_book_entry(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wallet_id: String,
        id: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        label: Option<String>,
        notes: Option<String>,
        color_tag: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        is_favorite: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__update_address_book_entry_impl(
            port_,
            wallet_id,
            id,
            label,
            notes,
            color_tag,
            is_favorite,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__validate_mnemonic(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        mnemonic: String,
    ) {
        wire__crate__api__validate_mnemonic_impl(port_, mnemonic)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__verify_app_passphrase(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        passphrase: String,
    ) {
        wire__crate__api__verify_app_passphrase_impl(port_, passphrase)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__verify_duress_passphrase(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        passphrase: String,
        hash: String,
    ) {
        wire__crate__api__verify_duress_passphrase_impl(port_, passphrase, hash)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__verify_panic_pin(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        pin: String,
    ) {
        wire__crate__api__verify_panic_pin_impl(port_, pin)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__wallet_registry_exists(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__wallet_registry_exists_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__witness_refresh_outcome_default(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__witness_refresh_outcome_default_impl(port_)
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;
