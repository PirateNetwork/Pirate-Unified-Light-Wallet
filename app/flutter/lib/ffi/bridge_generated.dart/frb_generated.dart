// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'dart:async';
import 'dart:convert';

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import 'api.dart';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'models.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => 641769563;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'pirate_ffi_frb',
    ioDirectory: '../crates/pirate-ffi-frb/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<String> crateApiAcknowledgeSeedWarning();

  Future<AddressBookEntryFfi> crateApiAddAddressBookEntry(
      {required String walletId,
      required String address,
      required String label,
      required AddressBookColorTag colorTag,
      String? notes});

  Future<bool> crateApiAddressExistsInBook(
      {required String walletId, required String address});

  Future<bool> crateApiAreSeedScreenshotsBlocked();

  Future<String> crateApiBroadcastTx({required SignedTx signed});

  Future<PendingTx> crateApiBuildConsolidationTx(
      {required String walletId,
      required PlatformInt64 keyId,
      required String targetAddress,
      BigInt? feeOpt});

  Future<PendingTx> crateApiBuildSweepTx(
      {required String walletId,
      required String targetAddress,
      BigInt? feeOpt,
      Int64List? keyIdsFilter,
      Int64List? addressIdsFilter});

  Future<PendingTx> crateApiBuildTx(
      {required String walletId,
      required List<Output> outputs,
      BigInt? feeOpt});

  Future<PendingTx> crateApiBuildTxFiltered(
      {required String walletId,
      required List<Output> outputs,
      BigInt? feeOpt,
      Int64List? keyIdsFilter,
      Int64List? addressIdsFilter});

  Future<PendingTx> crateApiBuildTxForKey(
      {required String walletId,
      required PlatformInt64 keyId,
      required List<Output> outputs,
      BigInt? feeOpt});

  Future<void> crateApiCancelSeedExport();

  Future<void> crateApiCancelSync({required String walletId});

  Future<void> crateApiChangeAppPassphrase(
      {required String currentPassphrase, required String newPassphrase});

  Future<void> crateApiChangeAppPassphraseWithCached(
      {required String newPassphrase});

  Future<void> crateApiClearPanicPin();

  Future<String> crateApiCompleteSeedBiometric({required bool success});

  Future<String> crateApiCreateWallet(
      {required String name, int? entropyLen, int? birthdayOpt});

  Future<String> crateApiCurrentReceiveAddress({required String walletId});

  Future<void> crateApiDeleteAddressBookEntry(
      {required String walletId, required PlatformInt64 id});

  Future<void> crateApiDeleteWallet({required String walletId});

  Future<BigInt> crateApiEstimateFee(
      {required BigInt numOutputs, required bool hasMemo, String? feePolicy});

  Future<void> crateApiExitDecoyMode();

  Future<String> crateApiExportIvk({required String walletId});

  Future<String> crateApiExportIvkSecure({required String walletId});

  Future<KeyExportInfo> crateApiExportKeyGroupKeys(
      {required String walletId, required PlatformInt64 keyId});

  Future<String> crateApiExportOrchardIvk({required String walletId});

  Future<String> crateApiExportOrchardViewingKey({required String walletId});

  Future<String> crateApiExportSeed({required String walletId});

  Future<List<String>> crateApiExportSeedWithCachedPassphrase(
      {required String walletId});

  Future<List<String>> crateApiExportSeedWithPassphrase(
      {required String walletId, required String passphrase});

  Future<String?> crateApiFetchTransactionMemo(
      {required String walletId, required String txid, int? outputIndex});

  Future<String> crateApiFormatAmount({required BigInt arrrtoshis});

  Future<String> crateApiGenerateAddressForKey(
      {required String walletId,
      required PlatformInt64 keyId,
      required bool useOrchard});

  Future<String> crateApiGenerateMnemonic({int? wordCount});

  Future<String?> crateApiGetActiveWallet();

  Future<int> crateApiGetAddressBookCount({required String walletId});

  Future<AddressBookEntryFfi?> crateApiGetAddressBookEntry(
      {required String walletId, required PlatformInt64 id});

  Future<AddressBookEntryFfi?> crateApiGetAddressBookEntryByAddress(
      {required String walletId, required String address});

  Future<List<AddressBookEntryFfi>> crateApiGetAddressBookFavorites(
      {required String walletId});

  Future<Balance> crateApiGetBalance({required String walletId});

  Future<BuildInfo> crateApiGetBuildInfo();

  Future<CheckpointInfo?> crateApiGetCheckpointDetails(
      {required String walletId, required int height});

  Future<FeeInfo> crateApiGetFeeInfo();

  Future<BigInt?> crateApiGetIvkClipboardRemaining();

  Future<String?> crateApiGetLabelForAddress(
      {required String walletId, required String address});

  Future<CheckpointInfo?> crateApiGetLastCheckpoint({required String walletId});

  Future<String> crateApiGetLightdEndpoint({required String walletId});

  Future<LightdEndpoint> crateApiGetLightdEndpointConfig(
      {required String walletId});

  Future<NetworkInfo> crateApiGetNetworkInfo();

  Future<List<AddressBookEntryFfi>> crateApiGetRecentlyUsedAddresses(
      {required String walletId, required int limit});

  Future<String> crateApiGetRecommendedBackgroundSyncMode(
      {required String walletId, required int minutesSinceLast});

  Future<BigInt?> crateApiGetSeedClipboardRemaining();

  Future<String> crateApiGetSeedExportState();

  Future<SeedExportWarnings> crateApiGetSeedExportWarnings();

  Future<List<SyncLogEntryFfi>> crateApiGetSyncLogs(
      {required String walletId, int? limit});

  Future<TunnelMode> crateApiGetTunnel();

  Future<String> crateApiGetVaultMode();

  Future<WatchOnlyBannerInfo?> crateApiGetWatchOnlyBanner(
      {required String walletId});

  Future<WatchOnlyCapabilitiesInfo> crateApiGetWatchOnlyCapabilities(
      {required String walletId});

  Future<bool> crateApiHasAppPassphrase();

  Future<bool> crateApiHasPanicPin();

  Future<String> crateApiImportIvk(
      {required String name,
      required int birthday,
      String? saplingIvk,
      String? orchardIvk});

  Future<String> crateApiImportIvkAsWatchOnly(
      {required String name, required String ivk, required int birthdayHeight});

  Future<PlatformInt64> crateApiImportSpendingKey(
      {required String walletId,
      required int birthdayHeight,
      String? saplingKey,
      String? orchardKey,
      String? label});

  Future<bool> crateApiIsBackgroundSyncNeeded({required String walletId});

  Future<bool> crateApiIsDecoyMode();

  Future<bool> crateApiIsSyncRunning({required String walletId});

  Future<void> crateApiLabelAddress(
      {required String walletId, required String addr, required String label});

  Future<LightdEndpoint> crateApiLightdEndpointDefault();

  Future<String> crateApiLightdEndpointDisplayString(
      {required LightdEndpoint that});

  Future<String> crateApiLightdEndpointUrl({required LightdEndpoint that});

  Future<List<AddressBalanceInfo>> crateApiListAddressBalances(
      {required String walletId, PlatformInt64? keyId});

  Future<List<AddressBookEntryFfi>> crateApiListAddressBook(
      {required String walletId});

  Future<List<AddressInfo>> crateApiListAddresses({required String walletId});

  Future<List<KeyAddressInfo>> crateApiListAddressesForKey(
      {required String walletId, required PlatformInt64 keyId});

  Future<List<KeyGroupInfo>> crateApiListKeyGroups({required String walletId});

  Future<List<TxInfo>> crateApiListTransactions(
      {required String walletId, int? limit});

  Future<List<WalletMeta>> crateApiListWallets();

  Future<void> crateApiMarkAddressUsed(
      {required String walletId, required String address});

  Future<String> crateApiNextReceiveAddress({required String walletId});

  Future<BigInt> crateApiParseAmount({required String arrr});

  Future<void> crateApiRenameWallet(
      {required String walletId, required String newName});

  Future<void> crateApiRescan(
      {required String walletId, required int fromHeight});

  Future<void> crateApiResealDbKeysForBiometrics();

  Future<String> crateApiRestoreWallet(
      {required String name,
      required String mnemonic,
      String? passphraseOpt,
      int? birthdayOpt});

  Future<List<AddressBookEntryFfi>> crateApiSearchAddressBook(
      {required String walletId, required String query});

  Future<void> crateApiSetAddressColorTag(
      {required String walletId,
      required String addr,
      required AddressBookColorTag colorTag});

  Future<void> crateApiSetAppPassphrase({required String passphrase});

  Future<void> crateApiSetDecoyWalletName({required String name});

  Future<void> crateApiSetLightdEndpoint(
      {required String walletId, required String url, String? tlsPinOpt});

  Future<void> crateApiSetPanicPin({required String pin});

  Future<void> crateApiSetTunnel({required TunnelMode mode});

  Future<void> crateApiSetWalletBirthdayHeight(
      {required String walletId, required int birthdayHeight});

  Future<SignedTx> crateApiSignTx(
      {required String walletId, required PendingTx pending});

  Future<SignedTx> crateApiSignTxFiltered(
      {required String walletId,
      required PendingTx pending,
      Int64List? keyIdsFilter,
      Int64List? addressIdsFilter});

  Future<SignedTx> crateApiSignTxForKey(
      {required String walletId,
      required PendingTx pending,
      required PlatformInt64 keyId});

  Future<String> crateApiSkipSeedBiometric();

  Future<BackgroundSyncResult> crateApiStartBackgroundSync(
      {required String walletId, String? mode});

  Future<WalletBackgroundSyncResult> crateApiStartBackgroundSyncRoundRobin(
      {String? mode});

  Future<String> crateApiStartSeedExport({required String walletId});

  Future<void> crateApiStartSync(
      {required String walletId, required SyncMode mode});

  Future<void> crateApiSwitchWallet({required String walletId});

  Future<SyncStatus> crateApiSyncStatus({required String walletId});

  Future<NodeTestResult> crateApiTestNode(
      {required String url, String? tlsPin});

  Future<bool> crateApiToggleAddressBookFavorite(
      {required String walletId, required PlatformInt64 id});

  Future<void> crateApiUnlockApp({required String passphrase});

  Future<AddressBookEntryFfi> crateApiUpdateAddressBookEntry(
      {required String walletId,
      required PlatformInt64 id,
      String? label,
      String? notes,
      AddressBookColorTag? colorTag,
      bool? isFavorite});

  Future<bool> crateApiValidateMnemonic({required String mnemonic});

  Future<bool> crateApiVerifyAppPassphrase({required String passphrase});

  Future<bool> crateApiVerifyPanicPin({required String pin});

  Future<bool> crateApiWalletRegistryExists();
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<String> crateApiAcknowledgeSeedWarning() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 1, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiAcknowledgeSeedWarningConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAcknowledgeSeedWarningConstMeta =>
      const TaskConstMeta(
        debugName: 'acknowledge_seed_warning',
        argNames: [],
      );

  @override
  Future<AddressBookEntryFfi> crateApiAddAddressBookEntry(
      {required String walletId,
      required String address,
      required String label,
      required AddressBookColorTag colorTag,
      String? notes}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_String(address, serializer);
          sse_encode_String(label, serializer);
          sse_encode_opt_String(notes, serializer);
          sse_encode_address_book_color_tag(colorTag, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 2, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_address_book_entry_ffi,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiAddAddressBookEntryConstMeta,
        argValues: [walletId, address, label, notes, colorTag],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAddAddressBookEntryConstMeta =>
      const TaskConstMeta(
        debugName: 'add_address_book_entry',
        argNames: ['walletId', 'address', 'label', 'notes', 'colorTag'],
      );

  @override
  Future<bool> crateApiAddressExistsInBook(
      {required String walletId, required String address}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_String(address, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 3, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiAddressExistsInBookConstMeta,
        argValues: [walletId, address],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAddressExistsInBookConstMeta =>
      const TaskConstMeta(
        debugName: 'address_exists_in_book',
        argNames: ['walletId', 'address'],
      );

  @override
  Future<bool> crateApiAreSeedScreenshotsBlocked() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 4, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiAreSeedScreenshotsBlockedConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAreSeedScreenshotsBlockedConstMeta =>
      const TaskConstMeta(
        debugName: 'are_seed_screenshots_blocked',
        argNames: [],
      );

  @override
  Future<String> crateApiBroadcastTx({required SignedTx signed}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_signed_tx(signed, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 5, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiBroadcastTxConstMeta,
        argValues: [signed],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBroadcastTxConstMeta => const TaskConstMeta(
        debugName: 'broadcast_tx',
        argNames: ['signed'],
      );

  @override
  Future<PendingTx> crateApiBuildConsolidationTx(
      {required String walletId,
      required PlatformInt64 keyId,
      required String targetAddress,
      BigInt? feeOpt}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_i_64(keyId, serializer);
          sse_encode_String(targetAddress, serializer);
          sse_encode_opt_box_autoadd_u_64(feeOpt, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 6, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_pending_tx,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiBuildConsolidationTxConstMeta,
        argValues: [walletId, keyId, targetAddress, feeOpt],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBuildConsolidationTxConstMeta =>
      const TaskConstMeta(
        debugName: 'build_consolidation_tx',
        argNames: ['walletId', 'keyId', 'targetAddress', 'feeOpt'],
      );

  @override
  Future<PendingTx> crateApiBuildSweepTx(
      {required String walletId,
      required String targetAddress,
      BigInt? feeOpt,
      Int64List? keyIdsFilter,
      Int64List? addressIdsFilter}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_String(targetAddress, serializer);
          sse_encode_opt_box_autoadd_u_64(feeOpt, serializer);
          sse_encode_opt_list_prim_i_64_strict(keyIdsFilter, serializer);
          sse_encode_opt_list_prim_i_64_strict(addressIdsFilter, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 7, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_pending_tx,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiBuildSweepTxConstMeta,
        argValues: [
          walletId,
          targetAddress,
          feeOpt,
          keyIdsFilter,
          addressIdsFilter
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBuildSweepTxConstMeta => const TaskConstMeta(
        debugName: 'build_sweep_tx',
        argNames: [
          'walletId',
          'targetAddress',
          'feeOpt',
          'keyIdsFilter',
          'addressIdsFilter'
        ],
      );

  @override
  Future<PendingTx> crateApiBuildTx(
      {required String walletId,
      required List<Output> outputs,
      BigInt? feeOpt}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_list_output(outputs, serializer);
          sse_encode_opt_box_autoadd_u_64(feeOpt, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 8, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_pending_tx,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiBuildTxConstMeta,
        argValues: [walletId, outputs, feeOpt],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBuildTxConstMeta => const TaskConstMeta(
        debugName: 'build_tx',
        argNames: ['walletId', 'outputs', 'feeOpt'],
      );

  @override
  Future<PendingTx> crateApiBuildTxFiltered(
      {required String walletId,
      required List<Output> outputs,
      BigInt? feeOpt,
      Int64List? keyIdsFilter,
      Int64List? addressIdsFilter}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_list_output(outputs, serializer);
          sse_encode_opt_box_autoadd_u_64(feeOpt, serializer);
          sse_encode_opt_list_prim_i_64_strict(keyIdsFilter, serializer);
          sse_encode_opt_list_prim_i_64_strict(addressIdsFilter, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 9, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_pending_tx,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiBuildTxFilteredConstMeta,
        argValues: [walletId, outputs, feeOpt, keyIdsFilter, addressIdsFilter],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBuildTxFilteredConstMeta => const TaskConstMeta(
        debugName: 'build_tx_filtered',
        argNames: [
          'walletId',
          'outputs',
          'feeOpt',
          'keyIdsFilter',
          'addressIdsFilter'
        ],
      );

  @override
  Future<PendingTx> crateApiBuildTxForKey(
      {required String walletId,
      required PlatformInt64 keyId,
      required List<Output> outputs,
      BigInt? feeOpt}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_i_64(keyId, serializer);
          sse_encode_list_output(outputs, serializer);
          sse_encode_opt_box_autoadd_u_64(feeOpt, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 10, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_pending_tx,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiBuildTxForKeyConstMeta,
        argValues: [walletId, keyId, outputs, feeOpt],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBuildTxForKeyConstMeta => const TaskConstMeta(
        debugName: 'build_tx_for_key',
        argNames: ['walletId', 'keyId', 'outputs', 'feeOpt'],
      );

  @override
  Future<void> crateApiCancelSeedExport() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 11, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCancelSeedExportConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCancelSeedExportConstMeta => const TaskConstMeta(
        debugName: 'cancel_seed_export',
        argNames: [],
      );

  @override
  Future<void> crateApiCancelSync({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 12, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCancelSyncConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCancelSyncConstMeta => const TaskConstMeta(
        debugName: 'cancel_sync',
        argNames: ['walletId'],
      );

  @override
  Future<void> crateApiChangeAppPassphrase(
      {required String currentPassphrase, required String newPassphrase}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(currentPassphrase, serializer);
          sse_encode_String(newPassphrase, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 13, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChangeAppPassphraseConstMeta,
        argValues: [currentPassphrase, newPassphrase],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChangeAppPassphraseConstMeta =>
      const TaskConstMeta(
        debugName: 'change_app_passphrase',
        argNames: ['currentPassphrase', 'newPassphrase'],
      );

  @override
  Future<void> crateApiChangeAppPassphraseWithCached(
      {required String newPassphrase}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(newPassphrase, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 14, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiChangeAppPassphraseWithCachedConstMeta,
        argValues: [newPassphrase],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChangeAppPassphraseWithCachedConstMeta =>
      const TaskConstMeta(
        debugName: 'change_app_passphrase_with_cached',
        argNames: ['newPassphrase'],
      );

  @override
  Future<void> crateApiClearPanicPin() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 15, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiClearPanicPinConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiClearPanicPinConstMeta => const TaskConstMeta(
        debugName: 'clear_panic_pin',
        argNames: [],
      );

  @override
  Future<String> crateApiCompleteSeedBiometric({required bool success}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_bool(success, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 16, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCompleteSeedBiometricConstMeta,
        argValues: [success],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCompleteSeedBiometricConstMeta =>
      const TaskConstMeta(
        debugName: 'complete_seed_biometric',
        argNames: ['success'],
      );

  @override
  Future<String> crateApiCreateWallet(
      {required String name, int? entropyLen, int? birthdayOpt}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(name, serializer);
          sse_encode_opt_box_autoadd_u_32(entropyLen, serializer);
          sse_encode_opt_box_autoadd_u_32(birthdayOpt, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 17, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCreateWalletConstMeta,
        argValues: [name, entropyLen, birthdayOpt],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCreateWalletConstMeta => const TaskConstMeta(
        debugName: 'create_wallet',
        argNames: ['name', 'entropyLen', 'birthdayOpt'],
      );

  @override
  Future<String> crateApiCurrentReceiveAddress({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 18, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCurrentReceiveAddressConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCurrentReceiveAddressConstMeta =>
      const TaskConstMeta(
        debugName: 'current_receive_address',
        argNames: ['walletId'],
      );

  @override
  Future<void> crateApiDeleteAddressBookEntry(
      {required String walletId, required PlatformInt64 id}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_i_64(id, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 19, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDeleteAddressBookEntryConstMeta,
        argValues: [walletId, id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDeleteAddressBookEntryConstMeta =>
      const TaskConstMeta(
        debugName: 'delete_address_book_entry',
        argNames: ['walletId', 'id'],
      );

  @override
  Future<void> crateApiDeleteWallet({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 20, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDeleteWalletConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDeleteWalletConstMeta => const TaskConstMeta(
        debugName: 'delete_wallet',
        argNames: ['walletId'],
      );

  @override
  Future<BigInt> crateApiEstimateFee(
      {required BigInt numOutputs, required bool hasMemo, String? feePolicy}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_usize(numOutputs, serializer);
          sse_encode_bool(hasMemo, serializer);
          sse_encode_opt_String(feePolicy, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 21, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiEstimateFeeConstMeta,
        argValues: [numOutputs, hasMemo, feePolicy],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEstimateFeeConstMeta => const TaskConstMeta(
        debugName: 'estimate_fee',
        argNames: ['numOutputs', 'hasMemo', 'feePolicy'],
      );

  @override
  Future<void> crateApiExitDecoyMode() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 22, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiExitDecoyModeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiExitDecoyModeConstMeta => const TaskConstMeta(
        debugName: 'exit_decoy_mode',
        argNames: [],
      );

  @override
  Future<String> crateApiExportIvk({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 23, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiExportIvkConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiExportIvkConstMeta => const TaskConstMeta(
        debugName: 'export_ivk',
        argNames: ['walletId'],
      );

  @override
  Future<String> crateApiExportIvkSecure({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 24, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiExportIvkSecureConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiExportIvkSecureConstMeta => const TaskConstMeta(
        debugName: 'export_ivk_secure',
        argNames: ['walletId'],
      );

  @override
  Future<KeyExportInfo> crateApiExportKeyGroupKeys(
      {required String walletId, required PlatformInt64 keyId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_i_64(keyId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 25, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_key_export_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiExportKeyGroupKeysConstMeta,
        argValues: [walletId, keyId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiExportKeyGroupKeysConstMeta => const TaskConstMeta(
        debugName: 'export_key_group_keys',
        argNames: ['walletId', 'keyId'],
      );

  @override
  Future<String> crateApiExportOrchardIvk({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 26, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiExportOrchardIvkConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiExportOrchardIvkConstMeta => const TaskConstMeta(
        debugName: 'export_orchard_ivk',
        argNames: ['walletId'],
      );

  @override
  Future<String> crateApiExportOrchardViewingKey({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 27, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiExportOrchardViewingKeyConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiExportOrchardViewingKeyConstMeta =>
      const TaskConstMeta(
        debugName: 'export_orchard_viewing_key',
        argNames: ['walletId'],
      );

  @override
  Future<String> crateApiExportSeed({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 28, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiExportSeedConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiExportSeedConstMeta => const TaskConstMeta(
        debugName: 'export_seed',
        argNames: ['walletId'],
      );

  @override
  Future<List<String>> crateApiExportSeedWithCachedPassphrase(
      {required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 29, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiExportSeedWithCachedPassphraseConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiExportSeedWithCachedPassphraseConstMeta =>
      const TaskConstMeta(
        debugName: 'export_seed_with_cached_passphrase',
        argNames: ['walletId'],
      );

  @override
  Future<List<String>> crateApiExportSeedWithPassphrase(
      {required String walletId, required String passphrase}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_String(passphrase, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 30, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiExportSeedWithPassphraseConstMeta,
        argValues: [walletId, passphrase],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiExportSeedWithPassphraseConstMeta =>
      const TaskConstMeta(
        debugName: 'export_seed_with_passphrase',
        argNames: ['walletId', 'passphrase'],
      );

  @override
  Future<String?> crateApiFetchTransactionMemo(
      {required String walletId, required String txid, int? outputIndex}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_String(txid, serializer);
          sse_encode_opt_box_autoadd_u_32(outputIndex, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 31, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFetchTransactionMemoConstMeta,
        argValues: [walletId, txid, outputIndex],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFetchTransactionMemoConstMeta =>
      const TaskConstMeta(
        debugName: 'fetch_transaction_memo',
        argNames: ['walletId', 'txid', 'outputIndex'],
      );

  @override
  Future<String> crateApiFormatAmount({required BigInt arrrtoshis}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_64(arrrtoshis, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 32, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFormatAmountConstMeta,
        argValues: [arrrtoshis],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFormatAmountConstMeta => const TaskConstMeta(
        debugName: 'format_amount',
        argNames: ['arrrtoshis'],
      );

  @override
  Future<String> crateApiGenerateAddressForKey(
      {required String walletId,
      required PlatformInt64 keyId,
      required bool useOrchard}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_i_64(keyId, serializer);
          sse_encode_bool(useOrchard, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 33, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGenerateAddressForKeyConstMeta,
        argValues: [walletId, keyId, useOrchard],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGenerateAddressForKeyConstMeta =>
      const TaskConstMeta(
        debugName: 'generate_address_for_key',
        argNames: ['walletId', 'keyId', 'useOrchard'],
      );

  @override
  Future<String> crateApiGenerateMnemonic({int? wordCount}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_opt_box_autoadd_u_32(wordCount, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 34, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGenerateMnemonicConstMeta,
        argValues: [wordCount],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGenerateMnemonicConstMeta => const TaskConstMeta(
        debugName: 'generate_mnemonic',
        argNames: ['wordCount'],
      );

  @override
  Future<String?> crateApiGetActiveWallet() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 35, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetActiveWalletConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetActiveWalletConstMeta => const TaskConstMeta(
        debugName: 'get_active_wallet',
        argNames: [],
      );

  @override
  Future<int> crateApiGetAddressBookCount({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 36, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetAddressBookCountConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetAddressBookCountConstMeta =>
      const TaskConstMeta(
        debugName: 'get_address_book_count',
        argNames: ['walletId'],
      );

  @override
  Future<AddressBookEntryFfi?> crateApiGetAddressBookEntry(
      {required String walletId, required PlatformInt64 id}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_i_64(id, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 37, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_address_book_entry_ffi,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetAddressBookEntryConstMeta,
        argValues: [walletId, id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetAddressBookEntryConstMeta =>
      const TaskConstMeta(
        debugName: 'get_address_book_entry',
        argNames: ['walletId', 'id'],
      );

  @override
  Future<AddressBookEntryFfi?> crateApiGetAddressBookEntryByAddress(
      {required String walletId, required String address}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_String(address, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 38, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_address_book_entry_ffi,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetAddressBookEntryByAddressConstMeta,
        argValues: [walletId, address],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetAddressBookEntryByAddressConstMeta =>
      const TaskConstMeta(
        debugName: 'get_address_book_entry_by_address',
        argNames: ['walletId', 'address'],
      );

  @override
  Future<List<AddressBookEntryFfi>> crateApiGetAddressBookFavorites(
      {required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 39, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_address_book_entry_ffi,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetAddressBookFavoritesConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetAddressBookFavoritesConstMeta =>
      const TaskConstMeta(
        debugName: 'get_address_book_favorites',
        argNames: ['walletId'],
      );

  @override
  Future<Balance> crateApiGetBalance({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 40, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_balance,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetBalanceConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetBalanceConstMeta => const TaskConstMeta(
        debugName: 'get_balance',
        argNames: ['walletId'],
      );

  @override
  Future<BuildInfo> crateApiGetBuildInfo() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 41, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_build_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetBuildInfoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetBuildInfoConstMeta => const TaskConstMeta(
        debugName: 'get_build_info',
        argNames: [],
      );

  @override
  Future<CheckpointInfo?> crateApiGetCheckpointDetails(
      {required String walletId, required int height}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_u_32(height, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 42, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_checkpoint_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetCheckpointDetailsConstMeta,
        argValues: [walletId, height],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetCheckpointDetailsConstMeta =>
      const TaskConstMeta(
        debugName: 'get_checkpoint_details',
        argNames: ['walletId', 'height'],
      );

  @override
  Future<FeeInfo> crateApiGetFeeInfo() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 43, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_fee_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetFeeInfoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetFeeInfoConstMeta => const TaskConstMeta(
        debugName: 'get_fee_info',
        argNames: [],
      );

  @override
  Future<BigInt?> crateApiGetIvkClipboardRemaining() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 44, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_u_64,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetIvkClipboardRemainingConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetIvkClipboardRemainingConstMeta =>
      const TaskConstMeta(
        debugName: 'get_ivk_clipboard_remaining',
        argNames: [],
      );

  @override
  Future<String?> crateApiGetLabelForAddress(
      {required String walletId, required String address}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_String(address, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 45, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetLabelForAddressConstMeta,
        argValues: [walletId, address],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetLabelForAddressConstMeta => const TaskConstMeta(
        debugName: 'get_label_for_address',
        argNames: ['walletId', 'address'],
      );

  @override
  Future<CheckpointInfo?> crateApiGetLastCheckpoint(
      {required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 46, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_checkpoint_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetLastCheckpointConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetLastCheckpointConstMeta => const TaskConstMeta(
        debugName: 'get_last_checkpoint',
        argNames: ['walletId'],
      );

  @override
  Future<String> crateApiGetLightdEndpoint({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 47, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetLightdEndpointConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetLightdEndpointConstMeta => const TaskConstMeta(
        debugName: 'get_lightd_endpoint',
        argNames: ['walletId'],
      );

  @override
  Future<LightdEndpoint> crateApiGetLightdEndpointConfig(
      {required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 48, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_lightd_endpoint,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetLightdEndpointConfigConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetLightdEndpointConfigConstMeta =>
      const TaskConstMeta(
        debugName: 'get_lightd_endpoint_config',
        argNames: ['walletId'],
      );

  @override
  Future<NetworkInfo> crateApiGetNetworkInfo() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 49, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_network_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetNetworkInfoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetNetworkInfoConstMeta => const TaskConstMeta(
        debugName: 'get_network_info',
        argNames: [],
      );

  @override
  Future<List<AddressBookEntryFfi>> crateApiGetRecentlyUsedAddresses(
      {required String walletId, required int limit}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_u_32(limit, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 50, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_address_book_entry_ffi,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetRecentlyUsedAddressesConstMeta,
        argValues: [walletId, limit],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetRecentlyUsedAddressesConstMeta =>
      const TaskConstMeta(
        debugName: 'get_recently_used_addresses',
        argNames: ['walletId', 'limit'],
      );

  @override
  Future<String> crateApiGetRecommendedBackgroundSyncMode(
      {required String walletId, required int minutesSinceLast}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_u_32(minutesSinceLast, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 51, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetRecommendedBackgroundSyncModeConstMeta,
        argValues: [walletId, minutesSinceLast],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetRecommendedBackgroundSyncModeConstMeta =>
      const TaskConstMeta(
        debugName: 'get_recommended_background_sync_mode',
        argNames: ['walletId', 'minutesSinceLast'],
      );

  @override
  Future<BigInt?> crateApiGetSeedClipboardRemaining() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 52, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_u_64,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetSeedClipboardRemainingConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetSeedClipboardRemainingConstMeta =>
      const TaskConstMeta(
        debugName: 'get_seed_clipboard_remaining',
        argNames: [],
      );

  @override
  Future<String> crateApiGetSeedExportState() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 53, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetSeedExportStateConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetSeedExportStateConstMeta => const TaskConstMeta(
        debugName: 'get_seed_export_state',
        argNames: [],
      );

  @override
  Future<SeedExportWarnings> crateApiGetSeedExportWarnings() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 54, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_seed_export_warnings,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetSeedExportWarningsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetSeedExportWarningsConstMeta =>
      const TaskConstMeta(
        debugName: 'get_seed_export_warnings',
        argNames: [],
      );

  @override
  Future<List<SyncLogEntryFfi>> crateApiGetSyncLogs(
      {required String walletId, int? limit}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_opt_box_autoadd_u_32(limit, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 55, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_sync_log_entry_ffi,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetSyncLogsConstMeta,
        argValues: [walletId, limit],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetSyncLogsConstMeta => const TaskConstMeta(
        debugName: 'get_sync_logs',
        argNames: ['walletId', 'limit'],
      );

  @override
  Future<TunnelMode> crateApiGetTunnel() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 56, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_tunnel_mode,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetTunnelConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetTunnelConstMeta => const TaskConstMeta(
        debugName: 'get_tunnel',
        argNames: [],
      );

  @override
  Future<String> crateApiGetVaultMode() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 57, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetVaultModeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetVaultModeConstMeta => const TaskConstMeta(
        debugName: 'get_vault_mode',
        argNames: [],
      );

  @override
  Future<WatchOnlyBannerInfo?> crateApiGetWatchOnlyBanner(
      {required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 58, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_watch_only_banner_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetWatchOnlyBannerConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetWatchOnlyBannerConstMeta => const TaskConstMeta(
        debugName: 'get_watch_only_banner',
        argNames: ['walletId'],
      );

  @override
  Future<WatchOnlyCapabilitiesInfo> crateApiGetWatchOnlyCapabilities(
      {required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 59, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_watch_only_capabilities_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetWatchOnlyCapabilitiesConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetWatchOnlyCapabilitiesConstMeta =>
      const TaskConstMeta(
        debugName: 'get_watch_only_capabilities',
        argNames: ['walletId'],
      );

  @override
  Future<bool> crateApiHasAppPassphrase() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 60, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiHasAppPassphraseConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiHasAppPassphraseConstMeta => const TaskConstMeta(
        debugName: 'has_app_passphrase',
        argNames: [],
      );

  @override
  Future<bool> crateApiHasPanicPin() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 61, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiHasPanicPinConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiHasPanicPinConstMeta => const TaskConstMeta(
        debugName: 'has_panic_pin',
        argNames: [],
      );

  @override
  Future<String> crateApiImportIvk(
      {required String name,
      required int birthday,
      String? saplingIvk,
      String? orchardIvk}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(name, serializer);
          sse_encode_opt_String(saplingIvk, serializer);
          sse_encode_opt_String(orchardIvk, serializer);
          sse_encode_u_32(birthday, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 62, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiImportIvkConstMeta,
        argValues: [name, saplingIvk, orchardIvk, birthday],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiImportIvkConstMeta => const TaskConstMeta(
        debugName: 'import_ivk',
        argNames: ['name', 'saplingIvk', 'orchardIvk', 'birthday'],
      );

  @override
  Future<String> crateApiImportIvkAsWatchOnly(
      {required String name,
      required String ivk,
      required int birthdayHeight}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(name, serializer);
          sse_encode_String(ivk, serializer);
          sse_encode_u_32(birthdayHeight, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 63, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiImportIvkAsWatchOnlyConstMeta,
        argValues: [name, ivk, birthdayHeight],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiImportIvkAsWatchOnlyConstMeta =>
      const TaskConstMeta(
        debugName: 'import_ivk_as_watch_only',
        argNames: ['name', 'ivk', 'birthdayHeight'],
      );

  @override
  Future<PlatformInt64> crateApiImportSpendingKey(
      {required String walletId,
      required int birthdayHeight,
      String? saplingKey,
      String? orchardKey,
      String? label}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_opt_String(saplingKey, serializer);
          sse_encode_opt_String(orchardKey, serializer);
          sse_encode_opt_String(label, serializer);
          sse_encode_u_32(birthdayHeight, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 64, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_i_64,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiImportSpendingKeyConstMeta,
        argValues: [walletId, saplingKey, orchardKey, label, birthdayHeight],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiImportSpendingKeyConstMeta => const TaskConstMeta(
        debugName: 'import_spending_key',
        argNames: [
          'walletId',
          'saplingKey',
          'orchardKey',
          'label',
          'birthdayHeight'
        ],
      );

  @override
  Future<bool> crateApiIsBackgroundSyncNeeded({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 65, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiIsBackgroundSyncNeededConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsBackgroundSyncNeededConstMeta =>
      const TaskConstMeta(
        debugName: 'is_background_sync_needed',
        argNames: ['walletId'],
      );

  @override
  Future<bool> crateApiIsDecoyMode() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 66, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiIsDecoyModeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsDecoyModeConstMeta => const TaskConstMeta(
        debugName: 'is_decoy_mode',
        argNames: [],
      );

  @override
  Future<bool> crateApiIsSyncRunning({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 67, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiIsSyncRunningConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsSyncRunningConstMeta => const TaskConstMeta(
        debugName: 'is_sync_running',
        argNames: ['walletId'],
      );

  @override
  Future<void> crateApiLabelAddress(
      {required String walletId, required String addr, required String label}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_String(addr, serializer);
          sse_encode_String(label, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 68, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLabelAddressConstMeta,
        argValues: [walletId, addr, label],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLabelAddressConstMeta => const TaskConstMeta(
        debugName: 'label_address',
        argNames: ['walletId', 'addr', 'label'],
      );

  @override
  Future<LightdEndpoint> crateApiLightdEndpointDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 69, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_lightd_endpoint,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiLightdEndpointDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLightdEndpointDefaultConstMeta =>
      const TaskConstMeta(
        debugName: 'lightd_endpoint_default',
        argNames: [],
      );

  @override
  Future<String> crateApiLightdEndpointDisplayString(
      {required LightdEndpoint that}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_lightd_endpoint(that, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 70, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiLightdEndpointDisplayStringConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLightdEndpointDisplayStringConstMeta =>
      const TaskConstMeta(
        debugName: 'lightd_endpoint_display_string',
        argNames: ['that'],
      );

  @override
  Future<String> crateApiLightdEndpointUrl({required LightdEndpoint that}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_lightd_endpoint(that, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 71, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiLightdEndpointUrlConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLightdEndpointUrlConstMeta => const TaskConstMeta(
        debugName: 'lightd_endpoint_url',
        argNames: ['that'],
      );

  @override
  Future<List<AddressBalanceInfo>> crateApiListAddressBalances(
      {required String walletId, PlatformInt64? keyId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_opt_box_autoadd_i_64(keyId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 72, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_address_balance_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiListAddressBalancesConstMeta,
        argValues: [walletId, keyId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiListAddressBalancesConstMeta =>
      const TaskConstMeta(
        debugName: 'list_address_balances',
        argNames: ['walletId', 'keyId'],
      );

  @override
  Future<List<AddressBookEntryFfi>> crateApiListAddressBook(
      {required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 73, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_address_book_entry_ffi,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiListAddressBookConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiListAddressBookConstMeta => const TaskConstMeta(
        debugName: 'list_address_book',
        argNames: ['walletId'],
      );

  @override
  Future<List<AddressInfo>> crateApiListAddresses({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 74, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_address_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiListAddressesConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiListAddressesConstMeta => const TaskConstMeta(
        debugName: 'list_addresses',
        argNames: ['walletId'],
      );

  @override
  Future<List<KeyAddressInfo>> crateApiListAddressesForKey(
      {required String walletId, required PlatformInt64 keyId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_i_64(keyId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 75, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_key_address_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiListAddressesForKeyConstMeta,
        argValues: [walletId, keyId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiListAddressesForKeyConstMeta =>
      const TaskConstMeta(
        debugName: 'list_addresses_for_key',
        argNames: ['walletId', 'keyId'],
      );

  @override
  Future<List<KeyGroupInfo>> crateApiListKeyGroups({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 76, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_key_group_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiListKeyGroupsConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiListKeyGroupsConstMeta => const TaskConstMeta(
        debugName: 'list_key_groups',
        argNames: ['walletId'],
      );

  @override
  Future<List<TxInfo>> crateApiListTransactions(
      {required String walletId, int? limit}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_opt_box_autoadd_u_32(limit, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 77, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_tx_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiListTransactionsConstMeta,
        argValues: [walletId, limit],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiListTransactionsConstMeta => const TaskConstMeta(
        debugName: 'list_transactions',
        argNames: ['walletId', 'limit'],
      );

  @override
  Future<List<WalletMeta>> crateApiListWallets() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 78, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_wallet_meta,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiListWalletsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiListWalletsConstMeta => const TaskConstMeta(
        debugName: 'list_wallets',
        argNames: [],
      );

  @override
  Future<void> crateApiMarkAddressUsed(
      {required String walletId, required String address}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_String(address, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 79, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiMarkAddressUsedConstMeta,
        argValues: [walletId, address],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiMarkAddressUsedConstMeta => const TaskConstMeta(
        debugName: 'mark_address_used',
        argNames: ['walletId', 'address'],
      );

  @override
  Future<String> crateApiNextReceiveAddress({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 80, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiNextReceiveAddressConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiNextReceiveAddressConstMeta => const TaskConstMeta(
        debugName: 'next_receive_address',
        argNames: ['walletId'],
      );

  @override
  Future<BigInt> crateApiParseAmount({required String arrr}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(arrr, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 81, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiParseAmountConstMeta,
        argValues: [arrr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiParseAmountConstMeta => const TaskConstMeta(
        debugName: 'parse_amount',
        argNames: ['arrr'],
      );

  @override
  Future<void> crateApiRenameWallet(
      {required String walletId, required String newName}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_String(newName, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 82, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiRenameWalletConstMeta,
        argValues: [walletId, newName],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiRenameWalletConstMeta => const TaskConstMeta(
        debugName: 'rename_wallet',
        argNames: ['walletId', 'newName'],
      );

  @override
  Future<void> crateApiRescan(
      {required String walletId, required int fromHeight}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_u_32(fromHeight, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 83, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiRescanConstMeta,
        argValues: [walletId, fromHeight],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiRescanConstMeta => const TaskConstMeta(
        debugName: 'rescan',
        argNames: ['walletId', 'fromHeight'],
      );

  @override
  Future<void> crateApiResealDbKeysForBiometrics() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 84, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiResealDbKeysForBiometricsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiResealDbKeysForBiometricsConstMeta =>
      const TaskConstMeta(
        debugName: 'reseal_db_keys_for_biometrics',
        argNames: [],
      );

  @override
  Future<String> crateApiRestoreWallet(
      {required String name,
      required String mnemonic,
      String? passphraseOpt,
      int? birthdayOpt}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(name, serializer);
          sse_encode_String(mnemonic, serializer);
          sse_encode_opt_String(passphraseOpt, serializer);
          sse_encode_opt_box_autoadd_u_32(birthdayOpt, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 85, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiRestoreWalletConstMeta,
        argValues: [name, mnemonic, passphraseOpt, birthdayOpt],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiRestoreWalletConstMeta => const TaskConstMeta(
        debugName: 'restore_wallet',
        argNames: ['name', 'mnemonic', 'passphraseOpt', 'birthdayOpt'],
      );

  @override
  Future<List<AddressBookEntryFfi>> crateApiSearchAddressBook(
      {required String walletId, required String query}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_String(query, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 86, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_address_book_entry_ffi,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSearchAddressBookConstMeta,
        argValues: [walletId, query],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSearchAddressBookConstMeta => const TaskConstMeta(
        debugName: 'search_address_book',
        argNames: ['walletId', 'query'],
      );

  @override
  Future<void> crateApiSetAddressColorTag(
      {required String walletId,
      required String addr,
      required AddressBookColorTag colorTag}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_String(addr, serializer);
          sse_encode_address_book_color_tag(colorTag, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 87, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetAddressColorTagConstMeta,
        argValues: [walletId, addr, colorTag],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetAddressColorTagConstMeta => const TaskConstMeta(
        debugName: 'set_address_color_tag',
        argNames: ['walletId', 'addr', 'colorTag'],
      );

  @override
  Future<void> crateApiSetAppPassphrase({required String passphrase}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(passphrase, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 88, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetAppPassphraseConstMeta,
        argValues: [passphrase],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetAppPassphraseConstMeta => const TaskConstMeta(
        debugName: 'set_app_passphrase',
        argNames: ['passphrase'],
      );

  @override
  Future<void> crateApiSetDecoyWalletName({required String name}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(name, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 89, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetDecoyWalletNameConstMeta,
        argValues: [name],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetDecoyWalletNameConstMeta => const TaskConstMeta(
        debugName: 'set_decoy_wallet_name',
        argNames: ['name'],
      );

  @override
  Future<void> crateApiSetLightdEndpoint(
      {required String walletId, required String url, String? tlsPinOpt}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_String(url, serializer);
          sse_encode_opt_String(tlsPinOpt, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 90, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetLightdEndpointConstMeta,
        argValues: [walletId, url, tlsPinOpt],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetLightdEndpointConstMeta => const TaskConstMeta(
        debugName: 'set_lightd_endpoint',
        argNames: ['walletId', 'url', 'tlsPinOpt'],
      );

  @override
  Future<void> crateApiSetPanicPin({required String pin}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pin, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 91, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetPanicPinConstMeta,
        argValues: [pin],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetPanicPinConstMeta => const TaskConstMeta(
        debugName: 'set_panic_pin',
        argNames: ['pin'],
      );

  @override
  Future<void> crateApiSetTunnel({required TunnelMode mode}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_tunnel_mode(mode, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 92, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetTunnelConstMeta,
        argValues: [mode],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetTunnelConstMeta => const TaskConstMeta(
        debugName: 'set_tunnel',
        argNames: ['mode'],
      );

  @override
  Future<void> crateApiSetWalletBirthdayHeight(
      {required String walletId, required int birthdayHeight}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_u_32(birthdayHeight, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 93, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetWalletBirthdayHeightConstMeta,
        argValues: [walletId, birthdayHeight],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetWalletBirthdayHeightConstMeta =>
      const TaskConstMeta(
        debugName: 'set_wallet_birthday_height',
        argNames: ['walletId', 'birthdayHeight'],
      );

  @override
  Future<SignedTx> crateApiSignTx(
      {required String walletId, required PendingTx pending}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_box_autoadd_pending_tx(pending, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 94, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_signed_tx,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSignTxConstMeta,
        argValues: [walletId, pending],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSignTxConstMeta => const TaskConstMeta(
        debugName: 'sign_tx',
        argNames: ['walletId', 'pending'],
      );

  @override
  Future<SignedTx> crateApiSignTxFiltered(
      {required String walletId,
      required PendingTx pending,
      Int64List? keyIdsFilter,
      Int64List? addressIdsFilter}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_box_autoadd_pending_tx(pending, serializer);
          sse_encode_opt_list_prim_i_64_strict(keyIdsFilter, serializer);
          sse_encode_opt_list_prim_i_64_strict(addressIdsFilter, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 95, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_signed_tx,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSignTxFilteredConstMeta,
        argValues: [walletId, pending, keyIdsFilter, addressIdsFilter],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSignTxFilteredConstMeta => const TaskConstMeta(
        debugName: 'sign_tx_filtered',
        argNames: ['walletId', 'pending', 'keyIdsFilter', 'addressIdsFilter'],
      );

  @override
  Future<SignedTx> crateApiSignTxForKey(
      {required String walletId,
      required PendingTx pending,
      required PlatformInt64 keyId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_box_autoadd_pending_tx(pending, serializer);
          sse_encode_i_64(keyId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 96, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_signed_tx,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSignTxForKeyConstMeta,
        argValues: [walletId, pending, keyId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSignTxForKeyConstMeta => const TaskConstMeta(
        debugName: 'sign_tx_for_key',
        argNames: ['walletId', 'pending', 'keyId'],
      );

  @override
  Future<String> crateApiSkipSeedBiometric() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 97, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSkipSeedBiometricConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSkipSeedBiometricConstMeta => const TaskConstMeta(
        debugName: 'skip_seed_biometric',
        argNames: [],
      );

  @override
  Future<BackgroundSyncResult> crateApiStartBackgroundSync(
      {required String walletId, String? mode}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_opt_String(mode, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 98, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_background_sync_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiStartBackgroundSyncConstMeta,
        argValues: [walletId, mode],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStartBackgroundSyncConstMeta =>
      const TaskConstMeta(
        debugName: 'start_background_sync',
        argNames: ['walletId', 'mode'],
      );

  @override
  Future<WalletBackgroundSyncResult> crateApiStartBackgroundSyncRoundRobin(
      {String? mode}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_opt_String(mode, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 99, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_wallet_background_sync_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiStartBackgroundSyncRoundRobinConstMeta,
        argValues: [mode],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStartBackgroundSyncRoundRobinConstMeta =>
      const TaskConstMeta(
        debugName: 'start_background_sync_round_robin',
        argNames: ['mode'],
      );

  @override
  Future<String> crateApiStartSeedExport({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 100, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiStartSeedExportConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStartSeedExportConstMeta => const TaskConstMeta(
        debugName: 'start_seed_export',
        argNames: ['walletId'],
      );

  @override
  Future<void> crateApiStartSync(
      {required String walletId, required SyncMode mode}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_sync_mode(mode, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 101, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiStartSyncConstMeta,
        argValues: [walletId, mode],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStartSyncConstMeta => const TaskConstMeta(
        debugName: 'start_sync',
        argNames: ['walletId', 'mode'],
      );

  @override
  Future<void> crateApiSwitchWallet({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 102, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSwitchWalletConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSwitchWalletConstMeta => const TaskConstMeta(
        debugName: 'switch_wallet',
        argNames: ['walletId'],
      );

  @override
  Future<SyncStatus> crateApiSyncStatus({required String walletId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 103, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_sync_status,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSyncStatusConstMeta,
        argValues: [walletId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSyncStatusConstMeta => const TaskConstMeta(
        debugName: 'sync_status',
        argNames: ['walletId'],
      );

  @override
  Future<NodeTestResult> crateApiTestNode(
      {required String url, String? tlsPin}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(url, serializer);
          sse_encode_opt_String(tlsPin, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 104, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_node_test_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiTestNodeConstMeta,
        argValues: [url, tlsPin],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTestNodeConstMeta => const TaskConstMeta(
        debugName: 'test_node',
        argNames: ['url', 'tlsPin'],
      );

  @override
  Future<bool> crateApiToggleAddressBookFavorite(
      {required String walletId, required PlatformInt64 id}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_i_64(id, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 105, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiToggleAddressBookFavoriteConstMeta,
        argValues: [walletId, id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiToggleAddressBookFavoriteConstMeta =>
      const TaskConstMeta(
        debugName: 'toggle_address_book_favorite',
        argNames: ['walletId', 'id'],
      );

  @override
  Future<void> crateApiUnlockApp({required String passphrase}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(passphrase, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 106, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUnlockAppConstMeta,
        argValues: [passphrase],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnlockAppConstMeta => const TaskConstMeta(
        debugName: 'unlock_app',
        argNames: ['passphrase'],
      );

  @override
  Future<AddressBookEntryFfi> crateApiUpdateAddressBookEntry(
      {required String walletId,
      required PlatformInt64 id,
      String? label,
      String? notes,
      AddressBookColorTag? colorTag,
      bool? isFavorite}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(walletId, serializer);
          sse_encode_i_64(id, serializer);
          sse_encode_opt_String(label, serializer);
          sse_encode_opt_String(notes, serializer);
          sse_encode_opt_box_autoadd_address_book_color_tag(
              colorTag, serializer);
          sse_encode_opt_box_autoadd_bool(isFavorite, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 107, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_address_book_entry_ffi,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUpdateAddressBookEntryConstMeta,
        argValues: [walletId, id, label, notes, colorTag, isFavorite],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUpdateAddressBookEntryConstMeta =>
      const TaskConstMeta(
        debugName: 'update_address_book_entry',
        argNames: [
          'walletId',
          'id',
          'label',
          'notes',
          'colorTag',
          'isFavorite'
        ],
      );

  @override
  Future<bool> crateApiValidateMnemonic({required String mnemonic}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mnemonic, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 108, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiValidateMnemonicConstMeta,
        argValues: [mnemonic],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiValidateMnemonicConstMeta => const TaskConstMeta(
        debugName: 'validate_mnemonic',
        argNames: ['mnemonic'],
      );

  @override
  Future<bool> crateApiVerifyAppPassphrase({required String passphrase}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(passphrase, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 109, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiVerifyAppPassphraseConstMeta,
        argValues: [passphrase],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiVerifyAppPassphraseConstMeta =>
      const TaskConstMeta(
        debugName: 'verify_app_passphrase',
        argNames: ['passphrase'],
      );

  @override
  Future<bool> crateApiVerifyPanicPin({required String pin}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pin, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 110, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiVerifyPanicPinConstMeta,
        argValues: [pin],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiVerifyPanicPinConstMeta => const TaskConstMeta(
        debugName: 'verify_panic_pin',
        argNames: ['pin'],
      );

  @override
  Future<bool> crateApiWalletRegistryExists() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer,
              funcId: 111, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiWalletRegistryExistsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWalletRegistryExistsConstMeta =>
      const TaskConstMeta(
        debugName: 'wallet_registry_exists',
        argNames: [],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AddressBalanceInfo dco_decode_address_balance_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return AddressBalanceInfo(
      address: dco_decode_String(arr[0]),
      balance: dco_decode_u_64(arr[1]),
      spendable: dco_decode_u_64(arr[2]),
      pending: dco_decode_u_64(arr[3]),
      keyId: dco_decode_opt_box_autoadd_i_64(arr[4]),
      addressId: dco_decode_i_64(arr[5]),
      label: dco_decode_opt_String(arr[6]),
      createdAt: dco_decode_i_64(arr[7]),
      colorTag: dco_decode_address_book_color_tag(arr[8]),
      diversifierIndex: dco_decode_u_32(arr[9]),
    );
  }

  @protected
  AddressBookColorTag dco_decode_address_book_color_tag(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AddressBookColorTag.values[raw as int];
  }

  @protected
  AddressBookEntryFfi dco_decode_address_book_entry_ffi(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return AddressBookEntryFfi(
      id: dco_decode_i_64(arr[0]),
      walletId: dco_decode_String(arr[1]),
      address: dco_decode_String(arr[2]),
      label: dco_decode_String(arr[3]),
      notes: dco_decode_opt_String(arr[4]),
      colorTag: dco_decode_address_book_color_tag(arr[5]),
      isFavorite: dco_decode_bool(arr[6]),
      createdAt: dco_decode_i_64(arr[7]),
      updatedAt: dco_decode_i_64(arr[8]),
      lastUsedAt: dco_decode_opt_box_autoadd_i_64(arr[9]),
      useCount: dco_decode_u_32(arr[10]),
    );
  }

  @protected
  AddressInfo dco_decode_address_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return AddressInfo(
      address: dco_decode_String(arr[0]),
      diversifierIndex: dco_decode_u_32(arr[1]),
      label: dco_decode_opt_String(arr[2]),
      createdAt: dco_decode_i_64(arr[3]),
      colorTag: dco_decode_address_book_color_tag(arr[4]),
    );
  }

  @protected
  BackgroundSyncResult dco_decode_background_sync_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return BackgroundSyncResult(
      mode: dco_decode_String(arr[0]),
      blocksSynced: dco_decode_u_64(arr[1]),
      startHeight: dco_decode_u_64(arr[2]),
      endHeight: dco_decode_u_64(arr[3]),
      durationSecs: dco_decode_u_64(arr[4]),
      errors: dco_decode_list_String(arr[5]),
      newBalance: dco_decode_opt_box_autoadd_u_64(arr[6]),
      newTransactions: dco_decode_u_32(arr[7]),
    );
  }

  @protected
  Balance dco_decode_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Balance(
      total: dco_decode_u_64(arr[0]),
      spendable: dco_decode_u_64(arr[1]),
      pending: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  AddressBookColorTag dco_decode_box_autoadd_address_book_color_tag(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_address_book_color_tag(raw);
  }

  @protected
  AddressBookEntryFfi dco_decode_box_autoadd_address_book_entry_ffi(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_address_book_entry_ffi(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  CheckpointInfo dco_decode_box_autoadd_checkpoint_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_checkpoint_info(raw);
  }

  @protected
  PlatformInt64 dco_decode_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_i_64(raw);
  }

  @protected
  LightdEndpoint dco_decode_box_autoadd_lightd_endpoint(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_lightd_endpoint(raw);
  }

  @protected
  PendingTx dco_decode_box_autoadd_pending_tx(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_pending_tx(raw);
  }

  @protected
  SignedTx dco_decode_box_autoadd_signed_tx(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_signed_tx(raw);
  }

  @protected
  TunnelMode dco_decode_box_autoadd_tunnel_mode(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_tunnel_mode(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  WatchOnlyBannerInfo dco_decode_box_autoadd_watch_only_banner_info(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_watch_only_banner_info(raw);
  }

  @protected
  BuildInfo dco_decode_build_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return BuildInfo(
      version: dco_decode_String(arr[0]),
      gitCommit: dco_decode_String(arr[1]),
      buildDate: dco_decode_String(arr[2]),
      rustVersion: dco_decode_String(arr[3]),
      targetTriple: dco_decode_String(arr[4]),
    );
  }

  @protected
  CheckpointInfo dco_decode_checkpoint_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return CheckpointInfo(
      height: dco_decode_u_32(arr[0]),
      timestamp: dco_decode_i_64(arr[1]),
    );
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FeeInfo dco_decode_fee_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return FeeInfo(
      defaultFee: dco_decode_u_64(arr[0]),
      minFee: dco_decode_u_64(arr[1]),
      maxFee: dco_decode_u_64(arr[2]),
      feePerOutput: dco_decode_u_64(arr[3]),
      memoFeeMultiplier: dco_decode_f_64(arr[4]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  KeyAddressInfo dco_decode_key_address_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return KeyAddressInfo(
      keyId: dco_decode_i_64(arr[0]),
      address: dco_decode_String(arr[1]),
      diversifierIndex: dco_decode_u_32(arr[2]),
      label: dco_decode_opt_String(arr[3]),
      createdAt: dco_decode_i_64(arr[4]),
      colorTag: dco_decode_address_book_color_tag(arr[5]),
    );
  }

  @protected
  KeyExportInfo dco_decode_key_export_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return KeyExportInfo(
      keyId: dco_decode_i_64(arr[0]),
      saplingViewingKey: dco_decode_opt_String(arr[1]),
      orchardViewingKey: dco_decode_opt_String(arr[2]),
      saplingSpendingKey: dco_decode_opt_String(arr[3]),
      orchardSpendingKey: dco_decode_opt_String(arr[4]),
    );
  }

  @protected
  KeyGroupInfo dco_decode_key_group_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return KeyGroupInfo(
      id: dco_decode_i_64(arr[0]),
      label: dco_decode_opt_String(arr[1]),
      keyType: dco_decode_key_type_info(arr[2]),
      spendable: dco_decode_bool(arr[3]),
      hasSapling: dco_decode_bool(arr[4]),
      hasOrchard: dco_decode_bool(arr[5]),
      birthdayHeight: dco_decode_i_64(arr[6]),
      createdAt: dco_decode_i_64(arr[7]),
    );
  }

  @protected
  KeyTypeInfo dco_decode_key_type_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return KeyTypeInfo.values[raw as int];
  }

  @protected
  LightdEndpoint dco_decode_lightd_endpoint(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return LightdEndpoint(
      host: dco_decode_String(arr[0]),
      port: dco_decode_u_16(arr[1]),
      useTls: dco_decode_bool(arr[2]),
      tlsPin: dco_decode_opt_String(arr[3]),
      label: dco_decode_opt_String(arr[4]),
    );
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<AddressBalanceInfo> dco_decode_list_address_balance_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_address_balance_info).toList();
  }

  @protected
  List<AddressBookEntryFfi> dco_decode_list_address_book_entry_ffi(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_address_book_entry_ffi)
        .toList();
  }

  @protected
  List<AddressInfo> dco_decode_list_address_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_address_info).toList();
  }

  @protected
  List<KeyAddressInfo> dco_decode_list_key_address_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_key_address_info).toList();
  }

  @protected
  List<KeyGroupInfo> dco_decode_list_key_group_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_key_group_info).toList();
  }

  @protected
  List<Output> dco_decode_list_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_output).toList();
  }

  @protected
  Int64List dco_decode_list_prim_i_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeInt64List(raw);
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<SyncLogEntryFfi> dco_decode_list_sync_log_entry_ffi(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_sync_log_entry_ffi).toList();
  }

  @protected
  List<TxInfo> dco_decode_list_tx_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tx_info).toList();
  }

  @protected
  List<WalletMeta> dco_decode_list_wallet_meta(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wallet_meta).toList();
  }

  @protected
  NetworkInfo dco_decode_network_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return NetworkInfo(
      name: dco_decode_String(arr[0]),
      coinType: dco_decode_u_32(arr[1]),
      rpcPort: dco_decode_u_16(arr[2]),
      defaultBirthday: dco_decode_u_32(arr[3]),
    );
  }

  @protected
  NodeTestResult dco_decode_node_test_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return NodeTestResult(
      success: dco_decode_bool(arr[0]),
      latestBlockHeight: dco_decode_opt_box_autoadd_u_64(arr[1]),
      transportMode: dco_decode_String(arr[2]),
      tlsEnabled: dco_decode_bool(arr[3]),
      tlsPinMatched: dco_decode_opt_box_autoadd_bool(arr[4]),
      expectedPin: dco_decode_opt_String(arr[5]),
      actualPin: dco_decode_opt_String(arr[6]),
      errorMessage: dco_decode_opt_String(arr[7]),
      responseTimeMs: dco_decode_u_64(arr[8]),
      serverVersion: dco_decode_opt_String(arr[9]),
      chainName: dco_decode_opt_String(arr[10]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  AddressBookColorTag? dco_decode_opt_box_autoadd_address_book_color_tag(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_address_book_color_tag(raw);
  }

  @protected
  AddressBookEntryFfi? dco_decode_opt_box_autoadd_address_book_entry_ffi(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_address_book_entry_ffi(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  CheckpointInfo? dco_decode_opt_box_autoadd_checkpoint_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_checkpoint_info(raw);
  }

  @protected
  PlatformInt64? dco_decode_opt_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_64(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  WatchOnlyBannerInfo? dco_decode_opt_box_autoadd_watch_only_banner_info(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_watch_only_banner_info(raw);
  }

  @protected
  Int64List? dco_decode_opt_list_prim_i_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_i_64_strict(raw);
  }

  @protected
  Output dco_decode_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Output(
      addr: dco_decode_String(arr[0]),
      amount: dco_decode_u_64(arr[1]),
      memo: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  PendingTx dco_decode_pending_tx(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return PendingTx(
      id: dco_decode_String(arr[0]),
      outputs: dco_decode_list_output(arr[1]),
      totalAmount: dco_decode_u_64(arr[2]),
      fee: dco_decode_u_64(arr[3]),
      change: dco_decode_u_64(arr[4]),
      inputTotal: dco_decode_u_64(arr[5]),
      numInputs: dco_decode_u_32(arr[6]),
      expiryHeight: dco_decode_u_32(arr[7]),
      createdAt: dco_decode_i_64(arr[8]),
    );
  }

  @protected
  SeedExportWarnings dco_decode_seed_export_warnings(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return SeedExportWarnings(
      primary: dco_decode_String(arr[0]),
      secondary: dco_decode_String(arr[1]),
      backupInstructions: dco_decode_String(arr[2]),
      clipboardWarning: dco_decode_String(arr[3]),
    );
  }

  @protected
  SignedTx dco_decode_signed_tx(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return SignedTx(
      txid: dco_decode_String(arr[0]),
      raw: dco_decode_list_prim_u_8_strict(arr[1]),
      size: dco_decode_usize(arr[2]),
    );
  }

  @protected
  SyncLogEntryFfi dco_decode_sync_log_entry_ffi(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return SyncLogEntryFfi(
      timestamp: dco_decode_i_64(arr[0]),
      level: dco_decode_String(arr[1]),
      module: dco_decode_String(arr[2]),
      message: dco_decode_String(arr[3]),
    );
  }

  @protected
  SyncMode dco_decode_sync_mode(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SyncMode.values[raw as int];
  }

  @protected
  SyncStage dco_decode_sync_stage(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SyncStage.values[raw as int];
  }

  @protected
  SyncStatus dco_decode_sync_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return SyncStatus(
      localHeight: dco_decode_u_64(arr[0]),
      targetHeight: dco_decode_u_64(arr[1]),
      percent: dco_decode_f_64(arr[2]),
      eta: dco_decode_opt_box_autoadd_u_64(arr[3]),
      stage: dco_decode_sync_stage(arr[4]),
      lastCheckpoint: dco_decode_opt_box_autoadd_u_64(arr[5]),
      blocksPerSecond: dco_decode_f_64(arr[6]),
      notesDecrypted: dco_decode_u_64(arr[7]),
      lastBatchMs: dco_decode_u_64(arr[8]),
    );
  }

  @protected
  TunnelMode dco_decode_tunnel_mode(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return TunnelMode_Tor();
      case 1:
        return TunnelMode_Socks5(
          url: dco_decode_String(raw[1]),
        );
      case 2:
        return TunnelMode_Direct();
      default:
        throw Exception('unreachable');
    }
  }

  @protected
  TxInfo dco_decode_tx_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return TxInfo(
      txid: dco_decode_String(arr[0]),
      height: dco_decode_opt_box_autoadd_u_32(arr[1]),
      timestamp: dco_decode_i_64(arr[2]),
      amount: dco_decode_i_64(arr[3]),
      fee: dco_decode_u_64(arr[4]),
      memo: dco_decode_opt_String(arr[5]),
      confirmed: dco_decode_bool(arr[6]),
    );
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  WalletBackgroundSyncResult dco_decode_wallet_background_sync_result(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return WalletBackgroundSyncResult(
      walletId: dco_decode_String(arr[0]),
      mode: dco_decode_String(arr[1]),
      blocksSynced: dco_decode_u_64(arr[2]),
      startHeight: dco_decode_u_64(arr[3]),
      endHeight: dco_decode_u_64(arr[4]),
      durationSecs: dco_decode_u_64(arr[5]),
      errors: dco_decode_list_String(arr[6]),
      newBalance: dco_decode_opt_box_autoadd_u_64(arr[7]),
      newTransactions: dco_decode_u_32(arr[8]),
    );
  }

  @protected
  WalletMeta dco_decode_wallet_meta(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return WalletMeta(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      createdAt: dco_decode_i_64(arr[2]),
      watchOnly: dco_decode_bool(arr[3]),
      birthdayHeight: dco_decode_u_32(arr[4]),
      networkType: dco_decode_opt_String(arr[5]),
    );
  }

  @protected
  WatchOnlyBannerInfo dco_decode_watch_only_banner_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return WatchOnlyBannerInfo(
      bannerType: dco_decode_String(arr[0]),
      title: dco_decode_String(arr[1]),
      subtitle: dco_decode_String(arr[2]),
      icon: dco_decode_String(arr[3]),
    );
  }

  @protected
  WatchOnlyCapabilitiesInfo dco_decode_watch_only_capabilities_info(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return WatchOnlyCapabilitiesInfo(
      canViewIncoming: dco_decode_bool(arr[0]),
      canViewOutgoing: dco_decode_bool(arr[1]),
      canSpend: dco_decode_bool(arr[2]),
      canExportSeed: dco_decode_bool(arr[3]),
      canGenerateAddresses: dco_decode_bool(arr[4]),
      isWatchOnly: dco_decode_bool(arr[5]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AddressBalanceInfo sse_decode_address_balance_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_address = sse_decode_String(deserializer);
    final var_balance = sse_decode_u_64(deserializer);
    final var_spendable = sse_decode_u_64(deserializer);
    final var_pending = sse_decode_u_64(deserializer);
    final var_keyId = sse_decode_opt_box_autoadd_i_64(deserializer);
    final var_addressId = sse_decode_i_64(deserializer);
    final var_label = sse_decode_opt_String(deserializer);
    final var_createdAt = sse_decode_i_64(deserializer);
    final var_colorTag = sse_decode_address_book_color_tag(deserializer);
    final var_diversifierIndex = sse_decode_u_32(deserializer);
    return AddressBalanceInfo(
        address: var_address,
        balance: var_balance,
        spendable: var_spendable,
        pending: var_pending,
        keyId: var_keyId,
        addressId: var_addressId,
        label: var_label,
        createdAt: var_createdAt,
        colorTag: var_colorTag,
        diversifierIndex: var_diversifierIndex);
  }

  @protected
  AddressBookColorTag sse_decode_address_book_color_tag(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_i_32(deserializer);
    return AddressBookColorTag.values[inner];
  }

  @protected
  AddressBookEntryFfi sse_decode_address_book_entry_ffi(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_id = sse_decode_i_64(deserializer);
    final var_walletId = sse_decode_String(deserializer);
    final var_address = sse_decode_String(deserializer);
    final var_label = sse_decode_String(deserializer);
    final var_notes = sse_decode_opt_String(deserializer);
    final var_colorTag = sse_decode_address_book_color_tag(deserializer);
    final var_isFavorite = sse_decode_bool(deserializer);
    final var_createdAt = sse_decode_i_64(deserializer);
    final var_updatedAt = sse_decode_i_64(deserializer);
    final var_lastUsedAt = sse_decode_opt_box_autoadd_i_64(deserializer);
    final var_useCount = sse_decode_u_32(deserializer);
    return AddressBookEntryFfi(
        id: var_id,
        walletId: var_walletId,
        address: var_address,
        label: var_label,
        notes: var_notes,
        colorTag: var_colorTag,
        isFavorite: var_isFavorite,
        createdAt: var_createdAt,
        updatedAt: var_updatedAt,
        lastUsedAt: var_lastUsedAt,
        useCount: var_useCount);
  }

  @protected
  AddressInfo sse_decode_address_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_address = sse_decode_String(deserializer);
    final var_diversifierIndex = sse_decode_u_32(deserializer);
    final var_label = sse_decode_opt_String(deserializer);
    final var_createdAt = sse_decode_i_64(deserializer);
    final var_colorTag = sse_decode_address_book_color_tag(deserializer);
    return AddressInfo(
        address: var_address,
        diversifierIndex: var_diversifierIndex,
        label: var_label,
        createdAt: var_createdAt,
        colorTag: var_colorTag);
  }

  @protected
  BackgroundSyncResult sse_decode_background_sync_result(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_mode = sse_decode_String(deserializer);
    final var_blocksSynced = sse_decode_u_64(deserializer);
    final var_startHeight = sse_decode_u_64(deserializer);
    final var_endHeight = sse_decode_u_64(deserializer);
    final var_durationSecs = sse_decode_u_64(deserializer);
    final var_errors = sse_decode_list_String(deserializer);
    final var_newBalance = sse_decode_opt_box_autoadd_u_64(deserializer);
    final var_newTransactions = sse_decode_u_32(deserializer);
    return BackgroundSyncResult(
        mode: var_mode,
        blocksSynced: var_blocksSynced,
        startHeight: var_startHeight,
        endHeight: var_endHeight,
        durationSecs: var_durationSecs,
        errors: var_errors,
        newBalance: var_newBalance,
        newTransactions: var_newTransactions);
  }

  @protected
  Balance sse_decode_balance(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_total = sse_decode_u_64(deserializer);
    final var_spendable = sse_decode_u_64(deserializer);
    final var_pending = sse_decode_u_64(deserializer);
    return Balance(
        total: var_total, spendable: var_spendable, pending: var_pending);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  AddressBookColorTag sse_decode_box_autoadd_address_book_color_tag(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_address_book_color_tag(deserializer);
  }

  @protected
  AddressBookEntryFfi sse_decode_box_autoadd_address_book_entry_ffi(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_address_book_entry_ffi(deserializer);
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_bool(deserializer);
  }

  @protected
  CheckpointInfo sse_decode_box_autoadd_checkpoint_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_checkpoint_info(deserializer);
  }

  @protected
  PlatformInt64 sse_decode_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_i_64(deserializer);
  }

  @protected
  LightdEndpoint sse_decode_box_autoadd_lightd_endpoint(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_lightd_endpoint(deserializer);
  }

  @protected
  PendingTx sse_decode_box_autoadd_pending_tx(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_pending_tx(deserializer);
  }

  @protected
  SignedTx sse_decode_box_autoadd_signed_tx(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_signed_tx(deserializer);
  }

  @protected
  TunnelMode sse_decode_box_autoadd_tunnel_mode(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_tunnel_mode(deserializer);
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_u_32(deserializer);
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_u_64(deserializer);
  }

  @protected
  WatchOnlyBannerInfo sse_decode_box_autoadd_watch_only_banner_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_watch_only_banner_info(deserializer);
  }

  @protected
  BuildInfo sse_decode_build_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_version = sse_decode_String(deserializer);
    final var_gitCommit = sse_decode_String(deserializer);
    final var_buildDate = sse_decode_String(deserializer);
    final var_rustVersion = sse_decode_String(deserializer);
    final var_targetTriple = sse_decode_String(deserializer);
    return BuildInfo(
        version: var_version,
        gitCommit: var_gitCommit,
        buildDate: var_buildDate,
        rustVersion: var_rustVersion,
        targetTriple: var_targetTriple);
  }

  @protected
  CheckpointInfo sse_decode_checkpoint_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_height = sse_decode_u_32(deserializer);
    final var_timestamp = sse_decode_i_64(deserializer);
    return CheckpointInfo(height: var_height, timestamp: var_timestamp);
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  FeeInfo sse_decode_fee_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_defaultFee = sse_decode_u_64(deserializer);
    final var_minFee = sse_decode_u_64(deserializer);
    final var_maxFee = sse_decode_u_64(deserializer);
    final var_feePerOutput = sse_decode_u_64(deserializer);
    final var_memoFeeMultiplier = sse_decode_f_64(deserializer);
    return FeeInfo(
        defaultFee: var_defaultFee,
        minFee: var_minFee,
        maxFee: var_maxFee,
        feePerOutput: var_feePerOutput,
        memoFeeMultiplier: var_memoFeeMultiplier);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  KeyAddressInfo sse_decode_key_address_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_keyId = sse_decode_i_64(deserializer);
    final var_address = sse_decode_String(deserializer);
    final var_diversifierIndex = sse_decode_u_32(deserializer);
    final var_label = sse_decode_opt_String(deserializer);
    final var_createdAt = sse_decode_i_64(deserializer);
    final var_colorTag = sse_decode_address_book_color_tag(deserializer);
    return KeyAddressInfo(
        keyId: var_keyId,
        address: var_address,
        diversifierIndex: var_diversifierIndex,
        label: var_label,
        createdAt: var_createdAt,
        colorTag: var_colorTag);
  }

  @protected
  KeyExportInfo sse_decode_key_export_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_keyId = sse_decode_i_64(deserializer);
    final var_saplingViewingKey = sse_decode_opt_String(deserializer);
    final var_orchardViewingKey = sse_decode_opt_String(deserializer);
    final var_saplingSpendingKey = sse_decode_opt_String(deserializer);
    final var_orchardSpendingKey = sse_decode_opt_String(deserializer);
    return KeyExportInfo(
        keyId: var_keyId,
        saplingViewingKey: var_saplingViewingKey,
        orchardViewingKey: var_orchardViewingKey,
        saplingSpendingKey: var_saplingSpendingKey,
        orchardSpendingKey: var_orchardSpendingKey);
  }

  @protected
  KeyGroupInfo sse_decode_key_group_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_id = sse_decode_i_64(deserializer);
    final var_label = sse_decode_opt_String(deserializer);
    final var_keyType = sse_decode_key_type_info(deserializer);
    final var_spendable = sse_decode_bool(deserializer);
    final var_hasSapling = sse_decode_bool(deserializer);
    final var_hasOrchard = sse_decode_bool(deserializer);
    final var_birthdayHeight = sse_decode_i_64(deserializer);
    final var_createdAt = sse_decode_i_64(deserializer);
    return KeyGroupInfo(
        id: var_id,
        label: var_label,
        keyType: var_keyType,
        spendable: var_spendable,
        hasSapling: var_hasSapling,
        hasOrchard: var_hasOrchard,
        birthdayHeight: var_birthdayHeight,
        createdAt: var_createdAt);
  }

  @protected
  KeyTypeInfo sse_decode_key_type_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_i_32(deserializer);
    return KeyTypeInfo.values[inner];
  }

  @protected
  LightdEndpoint sse_decode_lightd_endpoint(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_host = sse_decode_String(deserializer);
    final var_port = sse_decode_u_16(deserializer);
    final var_useTls = sse_decode_bool(deserializer);
    final var_tlsPin = sse_decode_opt_String(deserializer);
    final var_label = sse_decode_opt_String(deserializer);
    return LightdEndpoint(
        host: var_host,
        port: var_port,
        useTls: var_useTls,
        tlsPin: var_tlsPin,
        label: var_label);
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<AddressBalanceInfo> sse_decode_list_address_balance_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <AddressBalanceInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_address_balance_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<AddressBookEntryFfi> sse_decode_list_address_book_entry_ffi(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <AddressBookEntryFfi>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_address_book_entry_ffi(deserializer));
    }
    return ans_;
  }

  @protected
  List<AddressInfo> sse_decode_list_address_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <AddressInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_address_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<KeyAddressInfo> sse_decode_list_key_address_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <KeyAddressInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_key_address_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<KeyGroupInfo> sse_decode_list_key_group_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <KeyGroupInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_key_group_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<Output> sse_decode_list_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <Output>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_output(deserializer));
    }
    return ans_;
  }

  @protected
  Int64List sse_decode_list_prim_i_64_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getInt64List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<SyncLogEntryFfi> sse_decode_list_sync_log_entry_ffi(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <SyncLogEntryFfi>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_sync_log_entry_ffi(deserializer));
    }
    return ans_;
  }

  @protected
  List<TxInfo> sse_decode_list_tx_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <TxInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tx_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<WalletMeta> sse_decode_list_wallet_meta(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <WalletMeta>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wallet_meta(deserializer));
    }
    return ans_;
  }

  @protected
  NetworkInfo sse_decode_network_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_name = sse_decode_String(deserializer);
    final var_coinType = sse_decode_u_32(deserializer);
    final var_rpcPort = sse_decode_u_16(deserializer);
    final var_defaultBirthday = sse_decode_u_32(deserializer);
    return NetworkInfo(
        name: var_name,
        coinType: var_coinType,
        rpcPort: var_rpcPort,
        defaultBirthday: var_defaultBirthday);
  }

  @protected
  NodeTestResult sse_decode_node_test_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_success = sse_decode_bool(deserializer);
    final var_latestBlockHeight = sse_decode_opt_box_autoadd_u_64(deserializer);
    final var_transportMode = sse_decode_String(deserializer);
    final var_tlsEnabled = sse_decode_bool(deserializer);
    final var_tlsPinMatched = sse_decode_opt_box_autoadd_bool(deserializer);
    final var_expectedPin = sse_decode_opt_String(deserializer);
    final var_actualPin = sse_decode_opt_String(deserializer);
    final var_errorMessage = sse_decode_opt_String(deserializer);
    final var_responseTimeMs = sse_decode_u_64(deserializer);
    final var_serverVersion = sse_decode_opt_String(deserializer);
    final var_chainName = sse_decode_opt_String(deserializer);
    return NodeTestResult(
        success: var_success,
        latestBlockHeight: var_latestBlockHeight,
        transportMode: var_transportMode,
        tlsEnabled: var_tlsEnabled,
        tlsPinMatched: var_tlsPinMatched,
        expectedPin: var_expectedPin,
        actualPin: var_actualPin,
        errorMessage: var_errorMessage,
        responseTimeMs: var_responseTimeMs,
        serverVersion: var_serverVersion,
        chainName: var_chainName);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_String(deserializer);
    } else {
      return null;
    }
  }

  @protected
  AddressBookColorTag? sse_decode_opt_box_autoadd_address_book_color_tag(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_box_autoadd_address_book_color_tag(deserializer);
    } else {
      return null;
    }
  }

  @protected
  AddressBookEntryFfi? sse_decode_opt_box_autoadd_address_book_entry_ffi(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_box_autoadd_address_book_entry_ffi(deserializer);
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_box_autoadd_bool(deserializer);
    } else {
      return null;
    }
  }

  @protected
  CheckpointInfo? sse_decode_opt_box_autoadd_checkpoint_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_box_autoadd_checkpoint_info(deserializer);
    } else {
      return null;
    }
  }

  @protected
  PlatformInt64? sse_decode_opt_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_box_autoadd_i_64(deserializer);
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_box_autoadd_u_32(deserializer);
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_box_autoadd_u_64(deserializer);
    } else {
      return null;
    }
  }

  @protected
  WatchOnlyBannerInfo? sse_decode_opt_box_autoadd_watch_only_banner_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_box_autoadd_watch_only_banner_info(deserializer);
    } else {
      return null;
    }
  }

  @protected
  Int64List? sse_decode_opt_list_prim_i_64_strict(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_list_prim_i_64_strict(deserializer);
    } else {
      return null;
    }
  }

  @protected
  Output sse_decode_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_addr = sse_decode_String(deserializer);
    final var_amount = sse_decode_u_64(deserializer);
    final var_memo = sse_decode_opt_String(deserializer);
    return Output(addr: var_addr, amount: var_amount, memo: var_memo);
  }

  @protected
  PendingTx sse_decode_pending_tx(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_id = sse_decode_String(deserializer);
    final var_outputs = sse_decode_list_output(deserializer);
    final var_totalAmount = sse_decode_u_64(deserializer);
    final var_fee = sse_decode_u_64(deserializer);
    final var_change = sse_decode_u_64(deserializer);
    final var_inputTotal = sse_decode_u_64(deserializer);
    final var_numInputs = sse_decode_u_32(deserializer);
    final var_expiryHeight = sse_decode_u_32(deserializer);
    final var_createdAt = sse_decode_i_64(deserializer);
    return PendingTx(
        id: var_id,
        outputs: var_outputs,
        totalAmount: var_totalAmount,
        fee: var_fee,
        change: var_change,
        inputTotal: var_inputTotal,
        numInputs: var_numInputs,
        expiryHeight: var_expiryHeight,
        createdAt: var_createdAt);
  }

  @protected
  SeedExportWarnings sse_decode_seed_export_warnings(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_primary = sse_decode_String(deserializer);
    final var_secondary = sse_decode_String(deserializer);
    final var_backupInstructions = sse_decode_String(deserializer);
    final var_clipboardWarning = sse_decode_String(deserializer);
    return SeedExportWarnings(
        primary: var_primary,
        secondary: var_secondary,
        backupInstructions: var_backupInstructions,
        clipboardWarning: var_clipboardWarning);
  }

  @protected
  SignedTx sse_decode_signed_tx(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_txid = sse_decode_String(deserializer);
    final var_raw = sse_decode_list_prim_u_8_strict(deserializer);
    final var_size = sse_decode_usize(deserializer);
    return SignedTx(txid: var_txid, raw: var_raw, size: var_size);
  }

  @protected
  SyncLogEntryFfi sse_decode_sync_log_entry_ffi(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_timestamp = sse_decode_i_64(deserializer);
    final var_level = sse_decode_String(deserializer);
    final var_module = sse_decode_String(deserializer);
    final var_message = sse_decode_String(deserializer);
    return SyncLogEntryFfi(
        timestamp: var_timestamp,
        level: var_level,
        module: var_module,
        message: var_message);
  }

  @protected
  SyncMode sse_decode_sync_mode(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_i_32(deserializer);
    return SyncMode.values[inner];
  }

  @protected
  SyncStage sse_decode_sync_stage(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_i_32(deserializer);
    return SyncStage.values[inner];
  }

  @protected
  SyncStatus sse_decode_sync_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_localHeight = sse_decode_u_64(deserializer);
    final var_targetHeight = sse_decode_u_64(deserializer);
    final var_percent = sse_decode_f_64(deserializer);
    final var_eta = sse_decode_opt_box_autoadd_u_64(deserializer);
    final var_stage = sse_decode_sync_stage(deserializer);
    final var_lastCheckpoint = sse_decode_opt_box_autoadd_u_64(deserializer);
    final var_blocksPerSecond = sse_decode_f_64(deserializer);
    final var_notesDecrypted = sse_decode_u_64(deserializer);
    final var_lastBatchMs = sse_decode_u_64(deserializer);
    return SyncStatus(
        localHeight: var_localHeight,
        targetHeight: var_targetHeight,
        percent: var_percent,
        eta: var_eta,
        stage: var_stage,
        lastCheckpoint: var_lastCheckpoint,
        blocksPerSecond: var_blocksPerSecond,
        notesDecrypted: var_notesDecrypted,
        lastBatchMs: var_lastBatchMs);
  }

  @protected
  TunnelMode sse_decode_tunnel_mode(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return TunnelMode_Tor();
      case 1:
        final var_url = sse_decode_String(deserializer);
        return TunnelMode_Socks5(url: var_url);
      case 2:
        return TunnelMode_Direct();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  TxInfo sse_decode_tx_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_txid = sse_decode_String(deserializer);
    final var_height = sse_decode_opt_box_autoadd_u_32(deserializer);
    final var_timestamp = sse_decode_i_64(deserializer);
    final var_amount = sse_decode_i_64(deserializer);
    final var_fee = sse_decode_u_64(deserializer);
    final var_memo = sse_decode_opt_String(deserializer);
    final var_confirmed = sse_decode_bool(deserializer);
    return TxInfo(
        txid: var_txid,
        height: var_height,
        timestamp: var_timestamp,
        amount: var_amount,
        fee: var_fee,
        memo: var_memo,
        confirmed: var_confirmed);
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  WalletBackgroundSyncResult sse_decode_wallet_background_sync_result(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_walletId = sse_decode_String(deserializer);
    final var_mode = sse_decode_String(deserializer);
    final var_blocksSynced = sse_decode_u_64(deserializer);
    final var_startHeight = sse_decode_u_64(deserializer);
    final var_endHeight = sse_decode_u_64(deserializer);
    final var_durationSecs = sse_decode_u_64(deserializer);
    final var_errors = sse_decode_list_String(deserializer);
    final var_newBalance = sse_decode_opt_box_autoadd_u_64(deserializer);
    final var_newTransactions = sse_decode_u_32(deserializer);
    return WalletBackgroundSyncResult(
        walletId: var_walletId,
        mode: var_mode,
        blocksSynced: var_blocksSynced,
        startHeight: var_startHeight,
        endHeight: var_endHeight,
        durationSecs: var_durationSecs,
        errors: var_errors,
        newBalance: var_newBalance,
        newTransactions: var_newTransactions);
  }

  @protected
  WalletMeta sse_decode_wallet_meta(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_id = sse_decode_String(deserializer);
    final var_name = sse_decode_String(deserializer);
    final var_createdAt = sse_decode_i_64(deserializer);
    final var_watchOnly = sse_decode_bool(deserializer);
    final var_birthdayHeight = sse_decode_u_32(deserializer);
    final var_networkType = sse_decode_opt_String(deserializer);
    return WalletMeta(
        id: var_id,
        name: var_name,
        createdAt: var_createdAt,
        watchOnly: var_watchOnly,
        birthdayHeight: var_birthdayHeight,
        networkType: var_networkType);
  }

  @protected
  WatchOnlyBannerInfo sse_decode_watch_only_banner_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_bannerType = sse_decode_String(deserializer);
    final var_title = sse_decode_String(deserializer);
    final var_subtitle = sse_decode_String(deserializer);
    final var_icon = sse_decode_String(deserializer);
    return WatchOnlyBannerInfo(
        bannerType: var_bannerType,
        title: var_title,
        subtitle: var_subtitle,
        icon: var_icon);
  }

  @protected
  WatchOnlyCapabilitiesInfo sse_decode_watch_only_capabilities_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_canViewIncoming = sse_decode_bool(deserializer);
    final var_canViewOutgoing = sse_decode_bool(deserializer);
    final var_canSpend = sse_decode_bool(deserializer);
    final var_canExportSeed = sse_decode_bool(deserializer);
    final var_canGenerateAddresses = sse_decode_bool(deserializer);
    final var_isWatchOnly = sse_decode_bool(deserializer);
    return WatchOnlyCapabilitiesInfo(
        canViewIncoming: var_canViewIncoming,
        canViewOutgoing: var_canViewOutgoing,
        canSpend: var_canSpend,
        canExportSeed: var_canExportSeed,
        canGenerateAddresses: var_canGenerateAddresses,
        isWatchOnly: var_isWatchOnly);
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_address_balance_info(
      AddressBalanceInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.address, serializer);
    sse_encode_u_64(self.balance, serializer);
    sse_encode_u_64(self.spendable, serializer);
    sse_encode_u_64(self.pending, serializer);
    sse_encode_opt_box_autoadd_i_64(self.keyId, serializer);
    sse_encode_i_64(self.addressId, serializer);
    sse_encode_opt_String(self.label, serializer);
    sse_encode_i_64(self.createdAt, serializer);
    sse_encode_address_book_color_tag(self.colorTag, serializer);
    sse_encode_u_32(self.diversifierIndex, serializer);
  }

  @protected
  void sse_encode_address_book_color_tag(
      AddressBookColorTag self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_address_book_entry_ffi(
      AddressBookEntryFfi self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_String(self.walletId, serializer);
    sse_encode_String(self.address, serializer);
    sse_encode_String(self.label, serializer);
    sse_encode_opt_String(self.notes, serializer);
    sse_encode_address_book_color_tag(self.colorTag, serializer);
    sse_encode_bool(self.isFavorite, serializer);
    sse_encode_i_64(self.createdAt, serializer);
    sse_encode_i_64(self.updatedAt, serializer);
    sse_encode_opt_box_autoadd_i_64(self.lastUsedAt, serializer);
    sse_encode_u_32(self.useCount, serializer);
  }

  @protected
  void sse_encode_address_info(AddressInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.address, serializer);
    sse_encode_u_32(self.diversifierIndex, serializer);
    sse_encode_opt_String(self.label, serializer);
    sse_encode_i_64(self.createdAt, serializer);
    sse_encode_address_book_color_tag(self.colorTag, serializer);
  }

  @protected
  void sse_encode_background_sync_result(
      BackgroundSyncResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.mode, serializer);
    sse_encode_u_64(self.blocksSynced, serializer);
    sse_encode_u_64(self.startHeight, serializer);
    sse_encode_u_64(self.endHeight, serializer);
    sse_encode_u_64(self.durationSecs, serializer);
    sse_encode_list_String(self.errors, serializer);
    sse_encode_opt_box_autoadd_u_64(self.newBalance, serializer);
    sse_encode_u_32(self.newTransactions, serializer);
  }

  @protected
  void sse_encode_balance(Balance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.total, serializer);
    sse_encode_u_64(self.spendable, serializer);
    sse_encode_u_64(self.pending, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_address_book_color_tag(
      AddressBookColorTag self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_address_book_color_tag(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_address_book_entry_ffi(
      AddressBookEntryFfi self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_address_book_entry_ffi(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_checkpoint_info(
      CheckpointInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_checkpoint_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_64(
      PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_lightd_endpoint(
      LightdEndpoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_lightd_endpoint(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_pending_tx(
      PendingTx self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pending_tx(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_signed_tx(
      SignedTx self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_signed_tx(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_tunnel_mode(
      TunnelMode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_tunnel_mode(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_watch_only_banner_info(
      WatchOnlyBannerInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_watch_only_banner_info(self, serializer);
  }

  @protected
  void sse_encode_build_info(BuildInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.version, serializer);
    sse_encode_String(self.gitCommit, serializer);
    sse_encode_String(self.buildDate, serializer);
    sse_encode_String(self.rustVersion, serializer);
    sse_encode_String(self.targetTriple, serializer);
  }

  @protected
  void sse_encode_checkpoint_info(
      CheckpointInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.height, serializer);
    sse_encode_i_64(self.timestamp, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_fee_info(FeeInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.defaultFee, serializer);
    sse_encode_u_64(self.minFee, serializer);
    sse_encode_u_64(self.maxFee, serializer);
    sse_encode_u_64(self.feePerOutput, serializer);
    sse_encode_f_64(self.memoFeeMultiplier, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_key_address_info(
      KeyAddressInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.keyId, serializer);
    sse_encode_String(self.address, serializer);
    sse_encode_u_32(self.diversifierIndex, serializer);
    sse_encode_opt_String(self.label, serializer);
    sse_encode_i_64(self.createdAt, serializer);
    sse_encode_address_book_color_tag(self.colorTag, serializer);
  }

  @protected
  void sse_encode_key_export_info(
      KeyExportInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.keyId, serializer);
    sse_encode_opt_String(self.saplingViewingKey, serializer);
    sse_encode_opt_String(self.orchardViewingKey, serializer);
    sse_encode_opt_String(self.saplingSpendingKey, serializer);
    sse_encode_opt_String(self.orchardSpendingKey, serializer);
  }

  @protected
  void sse_encode_key_group_info(KeyGroupInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_opt_String(self.label, serializer);
    sse_encode_key_type_info(self.keyType, serializer);
    sse_encode_bool(self.spendable, serializer);
    sse_encode_bool(self.hasSapling, serializer);
    sse_encode_bool(self.hasOrchard, serializer);
    sse_encode_i_64(self.birthdayHeight, serializer);
    sse_encode_i_64(self.createdAt, serializer);
  }

  @protected
  void sse_encode_key_type_info(KeyTypeInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_lightd_endpoint(
      LightdEndpoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.host, serializer);
    sse_encode_u_16(self.port, serializer);
    sse_encode_bool(self.useTls, serializer);
    sse_encode_opt_String(self.tlsPin, serializer);
    sse_encode_opt_String(self.label, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_address_balance_info(
      List<AddressBalanceInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_address_balance_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_address_book_entry_ffi(
      List<AddressBookEntryFfi> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_address_book_entry_ffi(item, serializer);
    }
  }

  @protected
  void sse_encode_list_address_info(
      List<AddressInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_address_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_key_address_info(
      List<KeyAddressInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_key_address_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_key_group_info(
      List<KeyGroupInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_key_group_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_output(List<Output> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_output(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_i_64_strict(
      Int64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putInt64List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_sync_log_entry_ffi(
      List<SyncLogEntryFfi> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_sync_log_entry_ffi(item, serializer);
    }
  }

  @protected
  void sse_encode_list_tx_info(List<TxInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tx_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wallet_meta(
      List<WalletMeta> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wallet_meta(item, serializer);
    }
  }

  @protected
  void sse_encode_network_info(NetworkInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_u_32(self.coinType, serializer);
    sse_encode_u_16(self.rpcPort, serializer);
    sse_encode_u_32(self.defaultBirthday, serializer);
  }

  @protected
  void sse_encode_node_test_result(
      NodeTestResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_opt_box_autoadd_u_64(self.latestBlockHeight, serializer);
    sse_encode_String(self.transportMode, serializer);
    sse_encode_bool(self.tlsEnabled, serializer);
    sse_encode_opt_box_autoadd_bool(self.tlsPinMatched, serializer);
    sse_encode_opt_String(self.expectedPin, serializer);
    sse_encode_opt_String(self.actualPin, serializer);
    sse_encode_opt_String(self.errorMessage, serializer);
    sse_encode_u_64(self.responseTimeMs, serializer);
    sse_encode_opt_String(self.serverVersion, serializer);
    sse_encode_opt_String(self.chainName, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_address_book_color_tag(
      AddressBookColorTag? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_address_book_color_tag(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_address_book_entry_ffi(
      AddressBookEntryFfi? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_address_book_entry_ffi(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_checkpoint_info(
      CheckpointInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_checkpoint_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_64(
      PlatformInt64? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_watch_only_banner_info(
      WatchOnlyBannerInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_watch_only_banner_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_i_64_strict(
      Int64List? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_i_64_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_output(Output self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.addr, serializer);
    sse_encode_u_64(self.amount, serializer);
    sse_encode_opt_String(self.memo, serializer);
  }

  @protected
  void sse_encode_pending_tx(PendingTx self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_list_output(self.outputs, serializer);
    sse_encode_u_64(self.totalAmount, serializer);
    sse_encode_u_64(self.fee, serializer);
    sse_encode_u_64(self.change, serializer);
    sse_encode_u_64(self.inputTotal, serializer);
    sse_encode_u_32(self.numInputs, serializer);
    sse_encode_u_32(self.expiryHeight, serializer);
    sse_encode_i_64(self.createdAt, serializer);
  }

  @protected
  void sse_encode_seed_export_warnings(
      SeedExportWarnings self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.primary, serializer);
    sse_encode_String(self.secondary, serializer);
    sse_encode_String(self.backupInstructions, serializer);
    sse_encode_String(self.clipboardWarning, serializer);
  }

  @protected
  void sse_encode_signed_tx(SignedTx self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txid, serializer);
    sse_encode_list_prim_u_8_strict(self.raw, serializer);
    sse_encode_usize(self.size, serializer);
  }

  @protected
  void sse_encode_sync_log_entry_ffi(
      SyncLogEntryFfi self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.timestamp, serializer);
    sse_encode_String(self.level, serializer);
    sse_encode_String(self.module, serializer);
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_sync_mode(SyncMode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_sync_stage(SyncStage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_sync_status(SyncStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.localHeight, serializer);
    sse_encode_u_64(self.targetHeight, serializer);
    sse_encode_f_64(self.percent, serializer);
    sse_encode_opt_box_autoadd_u_64(self.eta, serializer);
    sse_encode_sync_stage(self.stage, serializer);
    sse_encode_opt_box_autoadd_u_64(self.lastCheckpoint, serializer);
    sse_encode_f_64(self.blocksPerSecond, serializer);
    sse_encode_u_64(self.notesDecrypted, serializer);
    sse_encode_u_64(self.lastBatchMs, serializer);
  }

  @protected
  void sse_encode_tunnel_mode(TunnelMode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case TunnelMode_Tor():
        sse_encode_i_32(0, serializer);
      case TunnelMode_Socks5(url: final url):
        sse_encode_i_32(1, serializer);
        sse_encode_String(url, serializer);
      case TunnelMode_Direct():
        sse_encode_i_32(2, serializer);
    }
  }

  @protected
  void sse_encode_tx_info(TxInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txid, serializer);
    sse_encode_opt_box_autoadd_u_32(self.height, serializer);
    sse_encode_i_64(self.timestamp, serializer);
    sse_encode_i_64(self.amount, serializer);
    sse_encode_u_64(self.fee, serializer);
    sse_encode_opt_String(self.memo, serializer);
    sse_encode_bool(self.confirmed, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_wallet_background_sync_result(
      WalletBackgroundSyncResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.walletId, serializer);
    sse_encode_String(self.mode, serializer);
    sse_encode_u_64(self.blocksSynced, serializer);
    sse_encode_u_64(self.startHeight, serializer);
    sse_encode_u_64(self.endHeight, serializer);
    sse_encode_u_64(self.durationSecs, serializer);
    sse_encode_list_String(self.errors, serializer);
    sse_encode_opt_box_autoadd_u_64(self.newBalance, serializer);
    sse_encode_u_32(self.newTransactions, serializer);
  }

  @protected
  void sse_encode_wallet_meta(WalletMeta self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_i_64(self.createdAt, serializer);
    sse_encode_bool(self.watchOnly, serializer);
    sse_encode_u_32(self.birthdayHeight, serializer);
    sse_encode_opt_String(self.networkType, serializer);
  }

  @protected
  void sse_encode_watch_only_banner_info(
      WatchOnlyBannerInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.bannerType, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.subtitle, serializer);
    sse_encode_String(self.icon, serializer);
  }

  @protected
  void sse_encode_watch_only_capabilities_info(
      WatchOnlyCapabilitiesInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.canViewIncoming, serializer);
    sse_encode_bool(self.canViewOutgoing, serializer);
    sse_encode_bool(self.canSpend, serializer);
    sse_encode_bool(self.canExportSeed, serializer);
    sse_encode_bool(self.canGenerateAddresses, serializer);
    sse_encode_bool(self.isWatchOnly, serializer);
  }
}
