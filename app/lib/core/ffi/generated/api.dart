// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'models.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `acquire_rescan_guard`, `address_book_color_from_ffi`, `address_book_color_to_ffi`, `address_book_entry_to_ffi`, `address_matches_expected_network_prefix`, `address_matches_type`, `address_prefix_network_type_for_endpoint`, `address_prefix_network_type`, `align_orchard_anchor_group`, `align_sapling_anchor_group`, `app_passphrase`, `apply_pending_sign_context`, `auto_consolidation_enabled`, `auto_consolidation_setting_key`, `auto_select_spend_key_id_for_amount`, `broadcast_tx_inner`, `build_tx_internal`, `cache_sync_status`, `cancel_sync_internal`, `choose_multi_key_change_sink_key_id`, `clear_pending_sign_context`, `clear_sync_runtime_cache`, `current_linux_fd_count`, `debug_log_path`, `decode_frontier_snapshot`, `decode_orchard_address_bytes_from_note_bytes`, `decode_sapling_address_bytes_from_note_bytes`, `decoy_wallet_meta`, `delete_wallet_meta`, `derive_db_key`, `detect_network_from_endpoint`, `disconnect_active_sync_channels`, `encode_orchard_extsk`, `encode_sapling_xfvk_from_bytes`, `ensure_decoy_wallet_state`, `ensure_not_decoy`, `ensure_primary_account_key`, `ensure_wallet_registry_loaded`, `ensure_wallet_registry_schema`, `escape_json`, `fetch_transaction_memo_inner`, `force_store_sealed_db_key`, `get_cached_sync_status`, `get_cached_transactions`, `get_registry_setting`, `get_wallet_meta`, `has_sync_engine_handle`, `infer_contributing_key_ids_for_amount`, `infer_key_network_type_from_addresses`, `install_debug_panic_hook`, `install_runtime_diagnostics`, `is_decoy_mode_active`, `is_guarded_witness_refresh_source`, `is_rescan_active`, `is_signing_active`, `is_sync_priming_active`, `key_type_to_info`, `load_pending_sign_context`, `load_registry_tunnel_mode`, `load_salt`, `load_sealed_key`, `load_wallet_registry_activity`, `load_wallet_registry_state`, `load_wallet_registry`, `log_orchard_address_samples`, `log_witness_repair_note_event`, `map_stage`, `mark_rescan_active`, `mark_runtime_clean_shutdown`, `mark_signing_active`, `mark_sync_priming_active`, `maybe_schedule_sync_recovery`, `maybe_store_sealed_db_key`, `network_type_name`, `new`, `normalize_filter_ids`, `normalize_pending_sign_filter_ids`, `note_balances_by_key_id`, `open_encrypted_db_with_migration`, `open_wallet_db_for`, `open_wallet_db_with_passphrase`, `open_wallet_registry_with_passphrase`, `open_wallet_registry`, `orchard_activation_override`, `orchard_anchor_for_selectable_note`, `orchard_anchor_from_frontier_hex`, `orchard_anchor_from_merkle_path`, `orchard_note_commitment_matches`, `parse_endpoint_url`, `parse_rfc3339_timestamp`, `parse_tunnel_mode_setting`, `pending_sign_note_id`, `pending_sign_note_snapshot`, `persist_registry_tunnel_mode`, `persist_wallet_meta`, `prime_sync_engine_for_witness`, `probe_sync_engine_handle`, `put_cached_transactions`, `quiesce_sync_for_sign`, `read_runtime_marker`, `redact_socks5_url`, `rederive_wallet_keys_for_network`, `reencrypt_blob`, `reencrypt_optional_blob`, `reencrypt_wallet_tables`, `refresh_duress_reverse_hash`, `refresh_selectable_note_positions_from_db`, `refresh_selectable_note_witnesses`, `registry_master_key`, `reseal_registry_db_key`, `reseal_wallet_db_key`, `resolve_change_diversifier_index`, `resolve_orchard_key_id_for_note`, `resolve_sapling_key_id_for_note`, `resolve_spend_key_id`, `resolve_wallet_birthday_height`, `resume_background_sync_after_sign`, `reverse_passphrase`, `run_on_runtime_blocking`, `run_on_runtime`, `run_sync_engine_task`, `runtime_marker_path`, `sapling_anchor_for_selectable_note`, `sapling_extfvk_hrp_for_network`, `sapling_extsk_hrp_for_network`, `sapling_note_commitment_matches`, `scan_sequential_addresses`, `schedule_target_height_update`, `selectable_note_lookup_key`, `set_active_wallet_registry`, `set_registry_setting`, `should_generate_orchard`, `should_suppress_live_tx_reads`, `sign_tx_internal`, `spawn_bootstrap_transport`, `spawn_disconnect_active_sync_channels`, `start_background_sync_inner`, `start_background_sync_round_robin_inner`, `store_pending_sign_context`, `store_sealed_key`, `sync_status_inner`, `test_node_inner`, `touch_wallet_last_synced`, `touch_wallet_last_used`, `truncate_for_log`, `try_unseal_db_key`, `tunnel_transport_config_for`, `tunnel_transport_config`, `tx_cache_key`, `txid_prefix_hex`, `unix_timestamp_millis`, `update_runtime_marker`, `validate_custom_duress_passphrase`, `validate_spendable_key`, `verify_app_passphrase_with_db`, `wait_for_sync_engine_idle`, `wait_for_sync_stop`, `wallet_base_dir`, `wallet_db_key_path`, `wallet_db_keys`, `wallet_db_path_for`, `wallet_db_salt_path`, `wallet_master_key`, `wallet_network_type`, `wallet_registry_key_path`, `wallet_registry_path`, `wallet_registry_salt_path`, `witness_note_type_label`, `write_runtime_debug_event`, `write_runtime_marker`, `write_salt`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ACTIVE_WALLET`, `DECOY_VAULT`, `LIGHTD_ENDPOINTS`, `PENDING_SIGN_CONTEXTS`, `PENDING_TUNNEL_MODE`, `PendingSignContext`, `PendingSignNoteId`, `PendingSignNoteSnapshot`, `RESCAN_ACTIVE`, `RESCAN_IN_FLIGHT`, `RescanActiveGuard`, `RescanGuard`, `SEED_EXPORT`, `SIGNING_ACTIVE`, `SYNC_PRIMING_ACTIVE`, `SYNC_RUNTIME_HANDLES`, `SYNC_SESSIONS`, `SYNC_STATUS_SNAPSHOT_CACHE`, `SequentialAddressScan`, `SigningGuard`, `SyncHandleProbe`, `SyncPrimingGuard`, `SyncResumeGuard`, `SyncRuntimeHandles`, `SyncSession`, `TUNNEL_MODE`, `TX_LIST_CACHE`, `WALLETS`, `WATCH_ONLY`, `WalletRegistryActivity`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `deref`, `deref`, `deref`, `deref`, `deref`, `deref`, `deref`, `deref`, `deref`, `deref`, `deref`, `deref`, `deref`, `deref`, `deref`, `deref`, `deref`, `drop`, `drop`, `drop`, `drop`, `drop`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `hash`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`, `initialize`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `default`

/// Create new wallet
///
/// Always generates a 24-word mnemonic seed phrase for new wallets.
/// For restoring wallets with 12 or 18 word seeds, use `restore_wallet()`.
Future<String> createWallet({
  required String name,
  int? entropyLen,
  int? birthdayOpt,
}) => RustLib.instance.api.crateApiCreateWallet(
  name: name,
  entropyLen: entropyLen,
  birthdayOpt: birthdayOpt,
);

/// Restore wallet from mnemonic
///
/// Supports restoring wallets with 12, 18, or 24 word mnemonic seeds
/// (for backward compatibility with old wallets that used 12 or 18 word seeds).
/// New wallets created with `create_wallet()` always use 24-word seeds.
Future<String> restoreWallet({
  required String name,
  required String mnemonic,
  String? passphraseOpt,
  int? birthdayOpt,
}) => RustLib.instance.api.crateApiRestoreWallet(
  name: name,
  mnemonic: mnemonic,
  passphraseOpt: passphraseOpt,
  birthdayOpt: birthdayOpt,
);

/// Check if wallet registry database file exists (without opening it)
///
/// This allows checking if wallets exist before the database is created or opened.
Future<bool> walletRegistryExists() =>
    RustLib.instance.api.crateApiWalletRegistryExists();

/// List all wallets
///
/// Returns empty list if database can't be opened (e.g., passphrase not set)
/// NOTE: This will CREATE the database file if it doesn't exist (via open_wallet_registry)
Future<List<WalletMeta>> listWallets() =>
    RustLib.instance.api.crateApiListWallets();

/// Switch active wallet
Future<void> switchWallet({required String walletId}) =>
    RustLib.instance.api.crateApiSwitchWallet(walletId: walletId);

/// Store app passphrase hash for local verification
///
/// IMPORTANT: This function opens/creates the database with the passphrase,
/// then stores the hash and caches the passphrase in memory for this session.
Future<void> setAppPassphrase({required String passphrase}) =>
    RustLib.instance.api.crateApiSetAppPassphrase(passphrase: passphrase);

/// Check if app passphrase is configured
Future<bool> hasAppPassphrase() =>
    RustLib.instance.api.crateApiHasAppPassphrase();

/// Verify app passphrase by attempting to open the database with it
Future<bool> verifyAppPassphrase({required String passphrase}) =>
    RustLib.instance.api.crateApiVerifyAppPassphrase(passphrase: passphrase);

/// Unlock app with passphrase (caches passphrase in memory for wallet access)
/// This allows wallets to be decrypted using the passphrase
Future<void> unlockApp({required String passphrase}) =>
    RustLib.instance.api.crateApiUnlockApp(passphrase: passphrase);

/// Change app passphrase and re-encrypt all wallet data with the new keys.
Future<void> changeAppPassphrase({
  required String currentPassphrase,
  required String newPassphrase,
}) => RustLib.instance.api.crateApiChangeAppPassphrase(
  currentPassphrase: currentPassphrase,
  newPassphrase: newPassphrase,
);

/// Change passphrase using the cached passphrase from the current session.
Future<void> changeAppPassphraseWithCached({required String newPassphrase}) =>
    RustLib.instance.api.crateApiChangeAppPassphraseWithCached(
      newPassphrase: newPassphrase,
    );

/// Reseal registry + wallet DB keys using current platform keystore mode.
///
/// This is used when biometrics are enabled/disabled to rewrap the DB keys
/// under the appropriate keystore policy without changing the passphrase.
Future<void> resealDbKeysForBiometrics() =>
    RustLib.instance.api.crateApiResealDbKeysForBiometrics();

/// Get auto-consolidation setting for a wallet.
Future<bool> getAutoConsolidationEnabled({required String walletId}) => RustLib
    .instance
    .api
    .crateApiGetAutoConsolidationEnabled(walletId: walletId);

/// Enable or disable auto-consolidation for a wallet.
Future<void> setAutoConsolidationEnabled({
  required String walletId,
  required bool enabled,
}) => RustLib.instance.api.crateApiSetAutoConsolidationEnabled(
  walletId: walletId,
  enabled: enabled,
);

/// Get the note count threshold that triggers auto-consolidation prompts.
Future<int> getAutoConsolidationThreshold() =>
    RustLib.instance.api.crateApiGetAutoConsolidationThreshold();

/// Count selectable notes eligible for auto-consolidation.
Future<int> getAutoConsolidationCandidateCount({required String walletId}) =>
    RustLib.instance.api.crateApiGetAutoConsolidationCandidateCount(
      walletId: walletId,
    );

/// Get active wallet ID
Future<String?> getActiveWallet() =>
    RustLib.instance.api.crateApiGetActiveWallet();

/// Rename wallet
Future<void> renameWallet({
  required String walletId,
  required String newName,
}) => RustLib.instance.api.crateApiRenameWallet(
  walletId: walletId,
  newName: newName,
);

/// Update wallet birthday height
Future<void> setWalletBirthdayHeight({
  required String walletId,
  required int birthdayHeight,
}) => RustLib.instance.api.crateApiSetWalletBirthdayHeight(
  walletId: walletId,
  birthdayHeight: birthdayHeight,
);

/// Delete wallet and its local database
Future<void> deleteWallet({required String walletId}) =>
    RustLib.instance.api.crateApiDeleteWallet(walletId: walletId);

/// Get current receive address for wallet
///
/// Returns the current diversified Sapling address from storage.
/// If no address exists, generates and stores the first address (index 0).
/// Call `next_receive_address` to rotate to a new unlinkable address.
Future<String> currentReceiveAddress({required String walletId}) =>
    RustLib.instance.api.crateApiCurrentReceiveAddress(walletId: walletId);

/// Generate next receive address (diversifier rotation)
///
/// Increments the diversifier index to generate a fresh, unlinkable address.
/// Address type (Sapling or Orchard) is determined by network and current block height.
/// Previous addresses remain valid for receiving funds.
Future<String> nextReceiveAddress({required String walletId}) =>
    RustLib.instance.api.crateApiNextReceiveAddress(walletId: walletId);

/// Label an address for address book
Future<void> labelAddress({
  required String walletId,
  required String addr,
  required String label,
}) => RustLib.instance.api.crateApiLabelAddress(
  walletId: walletId,
  addr: addr,
  label: label,
);

/// Set color tag for a wallet address
Future<void> setAddressColorTag({
  required String walletId,
  required String addr,
  required AddressBookColorTag colorTag,
}) => RustLib.instance.api.crateApiSetAddressColorTag(
  walletId: walletId,
  addr: addr,
  colorTag: colorTag,
);

/// Get all addresses for wallet with labels
Future<List<AddressInfo>> listAddresses({required String walletId}) =>
    RustLib.instance.api.crateApiListAddresses(walletId: walletId);

/// Get per-address balances for a wallet (optionally filtered by key group).
Future<List<AddressBalanceInfo>> listAddressBalances({
  required String walletId,
  PlatformInt64? keyId,
}) => RustLib.instance.api.crateApiListAddressBalances(
  walletId: walletId,
  keyId: keyId,
);

/// List address book entries for a wallet
Future<List<AddressBookEntryFfi>> listAddressBook({required String walletId}) =>
    RustLib.instance.api.crateApiListAddressBook(walletId: walletId);

/// Add an address book entry
Future<AddressBookEntryFfi> addAddressBookEntry({
  required String walletId,
  required String address,
  required String label,
  String? notes,
  required AddressBookColorTag colorTag,
}) => RustLib.instance.api.crateApiAddAddressBookEntry(
  walletId: walletId,
  address: address,
  label: label,
  notes: notes,
  colorTag: colorTag,
);

/// Update an address book entry
Future<AddressBookEntryFfi> updateAddressBookEntry({
  required String walletId,
  required PlatformInt64 id,
  String? label,
  String? notes,
  AddressBookColorTag? colorTag,
  bool? isFavorite,
}) => RustLib.instance.api.crateApiUpdateAddressBookEntry(
  walletId: walletId,
  id: id,
  label: label,
  notes: notes,
  colorTag: colorTag,
  isFavorite: isFavorite,
);

/// Delete an address book entry
Future<void> deleteAddressBookEntry({
  required String walletId,
  required PlatformInt64 id,
}) => RustLib.instance.api.crateApiDeleteAddressBookEntry(
  walletId: walletId,
  id: id,
);

/// Toggle favorite status for an entry
Future<bool> toggleAddressBookFavorite({
  required String walletId,
  required PlatformInt64 id,
}) => RustLib.instance.api.crateApiToggleAddressBookFavorite(
  walletId: walletId,
  id: id,
);

/// Mark an address as used
Future<void> markAddressUsed({
  required String walletId,
  required String address,
}) => RustLib.instance.api.crateApiMarkAddressUsed(
  walletId: walletId,
  address: address,
);

/// Get label for an address
Future<String?> getLabelForAddress({
  required String walletId,
  required String address,
}) => RustLib.instance.api.crateApiGetLabelForAddress(
  walletId: walletId,
  address: address,
);

/// Check if an address exists in the book
Future<bool> addressExistsInBook({
  required String walletId,
  required String address,
}) => RustLib.instance.api.crateApiAddressExistsInBook(
  walletId: walletId,
  address: address,
);

/// Count address book entries
Future<int> getAddressBookCount({required String walletId}) =>
    RustLib.instance.api.crateApiGetAddressBookCount(walletId: walletId);

/// Get entry by ID
Future<AddressBookEntryFfi?> getAddressBookEntry({
  required String walletId,
  required PlatformInt64 id,
}) => RustLib.instance.api.crateApiGetAddressBookEntry(
  walletId: walletId,
  id: id,
);

/// Get entry by address
Future<AddressBookEntryFfi?> getAddressBookEntryByAddress({
  required String walletId,
  required String address,
}) => RustLib.instance.api.crateApiGetAddressBookEntryByAddress(
  walletId: walletId,
  address: address,
);

/// Search entries by query
Future<List<AddressBookEntryFfi>> searchAddressBook({
  required String walletId,
  required String query,
}) => RustLib.instance.api.crateApiSearchAddressBook(
  walletId: walletId,
  query: query,
);

/// List favorites
Future<List<AddressBookEntryFfi>> getAddressBookFavorites({
  required String walletId,
}) => RustLib.instance.api.crateApiGetAddressBookFavorites(walletId: walletId);

/// List recently used addresses
Future<List<AddressBookEntryFfi>> getRecentlyUsedAddresses({
  required String walletId,
  required int limit,
}) => RustLib.instance.api.crateApiGetRecentlyUsedAddresses(
  walletId: walletId,
  limit: limit,
);

/// Export Sapling viewing key from full wallet.
///
/// Uses the zxviews... Bech32 format for watch-only wallets.
Future<String> exportIvk({required String walletId}) =>
    RustLib.instance.api.crateApiExportIvk(walletId: walletId);

/// Export Orchard Extended Full Viewing Key as Bech32 (for watch-only wallets)
///
/// Returns Bech32-encoded string with the network-specific HRP.
/// Uses the standard Orchard viewing key export format.
/// Use export_ivk() for Sapling viewing keys (zxviews... format).
Future<String> exportOrchardViewingKey({required String walletId}) =>
    RustLib.instance.api.crateApiExportOrchardViewingKey(walletId: walletId);

/// Export legacy Orchard viewing key (returns hex-encoded 64 bytes) - DEPRECATED
///
/// Use export_orchard_viewing_key() instead for watch-only wallets.
/// This method is kept for backward compatibility.
Future<String> exportOrchardIvk({required String walletId}) =>
    RustLib.instance.api.crateApiExportOrchardIvk(walletId: walletId);

/// Import viewing keys (watch-only wallet).
///
/// Supports Sapling viewing keys (zxviews...) and Orchard extended viewing keys (bech32).
/// If both are provided, creates a watch-only wallet that can view both Sapling and Orchard transactions.
Future<String> importIvk({
  required String name,
  String? saplingIvk,
  String? orchardIvk,
  required int birthday,
}) => RustLib.instance.api.crateApiImportIvk(
  name: name,
  saplingIvk: saplingIvk,
  orchardIvk: orchardIvk,
  birthday: birthday,
);

/// List key groups for the active wallet account.
Future<List<KeyGroupInfo>> listKeyGroups({required String walletId}) =>
    RustLib.instance.api.crateApiListKeyGroups(walletId: walletId);

/// Export viewing/spending keys for a specific key group.
Future<KeyExportInfo> exportKeyGroupKeys({
  required String walletId,
  required PlatformInt64 keyId,
}) => RustLib.instance.api.crateApiExportKeyGroupKeys(
  walletId: walletId,
  keyId: keyId,
);

/// List addresses for a specific key group.
Future<List<KeyAddressInfo>> listAddressesForKey({
  required String walletId,
  required PlatformInt64 keyId,
}) => RustLib.instance.api.crateApiListAddressesForKey(
  walletId: walletId,
  keyId: keyId,
);

/// Generate a new address for a specific key group.
Future<String> generateAddressForKey({
  required String walletId,
  required PlatformInt64 keyId,
  required bool useOrchard,
}) => RustLib.instance.api.crateApiGenerateAddressForKey(
  walletId: walletId,
  keyId: keyId,
  useOrchard: useOrchard,
);

/// Import a spending key into an existing wallet.
Future<PlatformInt64> importSpendingKey({
  required String walletId,
  String? saplingKey,
  String? orchardKey,
  String? label,
  required int birthdayHeight,
}) => RustLib.instance.api.crateApiImportSpendingKey(
  walletId: walletId,
  saplingKey: saplingKey,
  orchardKey: orchardKey,
  label: label,
  birthdayHeight: birthdayHeight,
);

/// Export mnemonic seed (DANGEROUS - requires authentication)
///
/// This is a high-security operation that requires:
/// 1. Passphrase verification (Argon2id)
/// 2. Biometric confirmation (if available)
/// 3. Screenshot blocking is enabled
///
/// Use `export_seed_with_passphrase` for the gated flow.
///
/// Note: Only works for wallets created/restored from seed.
/// Wallets imported from private key or watch-only wallets cannot export seed.
Future<String> exportSeed({required String walletId}) =>
    RustLib.instance.api.crateApiExportSeed(walletId: walletId);

/// Build transaction with note selection, fee calculation, and change.
Future<PendingTx> buildTx({
  required String walletId,
  required List<Output> outputs,
  BigInt? feeOpt,
}) => RustLib.instance.api.crateApiBuildTx(
  walletId: walletId,
  outputs: outputs,
  feeOpt: feeOpt,
);

/// Build transaction using notes from a specific key group.
Future<PendingTx> buildTxForKey({
  required String walletId,
  required PlatformInt64 keyId,
  required List<Output> outputs,
  BigInt? feeOpt,
}) => RustLib.instance.api.crateApiBuildTxForKey(
  walletId: walletId,
  keyId: keyId,
  outputs: outputs,
  feeOpt: feeOpt,
);

/// Build transaction using selected key groups or addresses.
Future<PendingTx> buildTxFiltered({
  required String walletId,
  required List<Output> outputs,
  BigInt? feeOpt,
  Int64List? keyIdsFilter,
  Int64List? addressIdsFilter,
}) => RustLib.instance.api.crateApiBuildTxFiltered(
  walletId: walletId,
  outputs: outputs,
  feeOpt: feeOpt,
  keyIdsFilter: keyIdsFilter,
  addressIdsFilter: addressIdsFilter,
);

/// Build a consolidation transaction for a key group.
Future<PendingTx> buildConsolidationTx({
  required String walletId,
  required PlatformInt64 keyId,
  required String targetAddress,
  BigInt? feeOpt,
}) => RustLib.instance.api.crateApiBuildConsolidationTx(
  walletId: walletId,
  keyId: keyId,
  targetAddress: targetAddress,
  feeOpt: feeOpt,
);

/// Build a sweep transaction from selected key groups or addresses.
/// Sends the full available balance minus fee to the target address.
Future<PendingTx> buildSweepTx({
  required String walletId,
  required String targetAddress,
  BigInt? feeOpt,
  Int64List? keyIdsFilter,
  Int64List? addressIdsFilter,
}) => RustLib.instance.api.crateApiBuildSweepTx(
  walletId: walletId,
  targetAddress: targetAddress,
  feeOpt: feeOpt,
  keyIdsFilter: keyIdsFilter,
  addressIdsFilter: addressIdsFilter,
);

/// Sign pending transaction (all spendable notes in the wallet)
Future<SignedTx> signTx({
  required String walletId,
  required PendingTx pending,
}) => RustLib.instance.api.crateApiSignTx(walletId: walletId, pending: pending);

/// Sign pending transaction using notes from a specific key group
Future<SignedTx> signTxForKey({
  required String walletId,
  required PendingTx pending,
  required PlatformInt64 keyId,
}) => RustLib.instance.api.crateApiSignTxForKey(
  walletId: walletId,
  pending: pending,
  keyId: keyId,
);

/// Sign pending transaction using selected key groups or addresses.
Future<SignedTx> signTxFiltered({
  required String walletId,
  required PendingTx pending,
  Int64List? keyIdsFilter,
  Int64List? addressIdsFilter,
}) => RustLib.instance.api.crateApiSignTxFiltered(
  walletId: walletId,
  pending: pending,
  keyIdsFilter: keyIdsFilter,
  addressIdsFilter: addressIdsFilter,
);

/// Broadcast signed transaction to the network
///
/// Sends transaction via lightwalletd gRPC SendTransaction.
/// Returns TxId on success, or error with details.
Future<String> broadcastTx({required SignedTx signed}) =>
    RustLib.instance.api.crateApiBroadcastTx(signed: signed);

/// Estimate fee for transaction without building it
Future<BigInt> estimateFee({
  required BigInt numOutputs,
  required bool hasMemo,
  String? feePolicy,
}) => RustLib.instance.api.crateApiEstimateFee(
  numOutputs: numOutputs,
  hasMemo: hasMemo,
  feePolicy: feePolicy,
);

/// Get fee information
Future<FeeInfo> getFeeInfo() => RustLib.instance.api.crateApiGetFeeInfo();

/// Start sync for a wallet
Future<void> startSync({required String walletId, required SyncMode mode}) =>
    RustLib.instance.api.crateApiStartSync(walletId: walletId, mode: mode);

/// Get sync status for a wallet with full performance metrics
Future<SyncStatus> syncStatus({required String walletId}) =>
    RustLib.instance.api.crateApiSyncStatus(walletId: walletId);

/// Get last checkpoint info for diagnostics
Future<CheckpointInfo?> getLastCheckpoint({required String walletId}) =>
    RustLib.instance.api.crateApiGetLastCheckpoint(walletId: walletId);

/// Rescan wallet from specific height
Future<void> rescan({required String walletId, required int fromHeight}) =>
    RustLib.instance.api.crateApiRescan(
      walletId: walletId,
      fromHeight: fromHeight,
    );

/// Cancel ongoing sync for a wallet.
Future<void> cancelSync({required String walletId}) =>
    RustLib.instance.api.crateApiCancelSync(walletId: walletId);

/// Check if sync is running for a wallet
Future<bool> isSyncRunning({required String walletId}) =>
    RustLib.instance.api.crateApiIsSyncRunning(walletId: walletId);

/// Start background sync for a wallet
///
/// This should be called from iOS BGAppRefreshTask or Android WorkManager.
/// The sync will run with time limits and battery constraints.
///
/// Note: This creates a new SyncEngine instance for background sync to avoid
/// conflicts with foreground sync. The background sync will use the same
/// wallet database and storage.
Future<BackgroundSyncResult> startBackgroundSync({
  required String walletId,
  String? mode,
}) => RustLib.instance.api.crateApiStartBackgroundSync(
  walletId: walletId,
  mode: mode,
);

/// Start background sync using round-robin scheduling with warm-wallet priority.
///
/// Chooses the next wallet to sync based on recent usage and rotates fairly
/// across wallets over successive runs.
Future<WalletBackgroundSyncResult> startBackgroundSyncRoundRobin({
  String? mode,
}) => RustLib.instance.api.crateApiStartBackgroundSyncRoundRobin(mode: mode);

/// Check if background sync is needed for a wallet
Future<bool> isBackgroundSyncNeeded({required String walletId}) =>
    RustLib.instance.api.crateApiIsBackgroundSyncNeeded(walletId: walletId);

/// Get recommended background sync mode based on time since last sync
Future<String> getRecommendedBackgroundSyncMode({
  required String walletId,
  required int minutesSinceLast,
}) => RustLib.instance.api.crateApiGetRecommendedBackgroundSyncMode(
  walletId: walletId,
  minutesSinceLast: minutesSinceLast,
);

/// Set lightwalletd endpoint
Future<void> setLightdEndpoint({
  required String walletId,
  required String url,
  String? tlsPinOpt,
}) => RustLib.instance.api.crateApiSetLightdEndpoint(
  walletId: walletId,
  url: url,
  tlsPinOpt: tlsPinOpt,
);

/// Get lightwalletd endpoint
Future<String> getLightdEndpoint({required String walletId}) =>
    RustLib.instance.api.crateApiGetLightdEndpoint(walletId: walletId);

/// Get full endpoint configuration
Future<LightdEndpoint> getLightdEndpointConfig({required String walletId}) =>
    RustLib.instance.api.crateApiGetLightdEndpointConfig(walletId: walletId);

/// Set network tunnel mode
Future<void> setTunnel({required TunnelMode mode}) =>
    RustLib.instance.api.crateApiSetTunnel(mode: mode);

/// Get current tunnel mode
Future<TunnelMode> getTunnel() => RustLib.instance.api.crateApiGetTunnel();

/// Bootstrap tunnel transport early (Tor/I2P/SOCKS5) without unlocking wallets.
Future<void> bootstrapTunnel({required TunnelMode mode}) =>
    RustLib.instance.api.crateApiBootstrapTunnel(mode: mode);

/// Shutdown any active transport manager (Tor/I2P/SOCKS5).
Future<void> shutdownTransport() =>
    RustLib.instance.api.crateApiShutdownTransport();

/// Configure Tor bridge settings (Snowflake/obfs4/custom) for censorship circumvention.
Future<void> setTorBridgeSettings({
  required bool useBridges,
  required bool fallbackToBridges,
  required String transport,
  required List<String> bridgeLines,
  String? transportPath,
}) => RustLib.instance.api.crateApiSetTorBridgeSettings(
  useBridges: useBridges,
  fallbackToBridges: fallbackToBridges,
  transport: transport,
  bridgeLines: bridgeLines,
  transportPath: transportPath,
);

/// Get current Tor bootstrap status for UI.
Future<String> getTorStatus() => RustLib.instance.api.crateApiGetTorStatus();

/// Rotate Tor exit circuits for new streams and reconnect sync channels.
Future<void> rotateTorExit() => RustLib.instance.api.crateApiRotateTorExit();

/// Get wallet balance
///
/// Calculates balance from unspent notes in the database.
/// - spendable: Confirmed unspent notes (with 10+ confirmations)
/// - pending: Unconfirmed unspent notes
/// - total: spendable + pending
Future<Balance> getBalance({required String walletId}) =>
    RustLib.instance.api.crateApiGetBalance(walletId: walletId);

/// List transactions
///
/// Returns transaction history from the database, aggregated by transaction ID.
/// Transactions are sorted by height descending (newest first).
Future<List<TxInfo>> listTransactions({required String walletId, int? limit}) =>
    RustLib.instance.api.crateApiListTransactions(
      walletId: walletId,
      limit: limit,
    );

/// Fetch and decrypt memo for a specific transaction (lazy memo decoding)
///
/// This function implements lazy memo decoding:
/// 1. Checks if memo already exists in database
/// 2. If exists, validates it by re-decrypting to ensure it's correct
/// 3. If missing or corrupted, fetches full transaction and decrypts memo
/// 4. Stores memo in database for future use
///
/// # Arguments
/// * `wallet_id` - Wallet ID
/// * `txid` - Transaction ID (hex string)
/// * `output_index` - Optional output index (if None, returns first memo found)
///
/// # Returns
/// Decoded memo string, or None if no memo exists or decryption fails
Future<String?> fetchTransactionMemo({
  required String walletId,
  required String txid,
  int? outputIndex,
}) => RustLib.instance.api.crateApiFetchTransactionMemo(
  walletId: walletId,
  txid: txid,
  outputIndex: outputIndex,
);

/// Generate new mnemonic (utility function for testing/development)
///
/// **Note**: New wallets always use 24-word seeds. This function is provided
/// for testing/utilities. For wallet creation, use `create_wallet()` which
/// always generates 24-word seeds.
///
/// # Arguments
/// * `word_count` - Number of words in mnemonic (12, 18, or 24). Defaults to 24 if None.
///
/// # Returns
/// BIP39 mnemonic phrase with the specified number of words
Future<String> generateMnemonic({int? wordCount}) =>
    RustLib.instance.api.crateApiGenerateMnemonic(wordCount: wordCount);

/// Validate mnemonic
Future<bool> validateMnemonic({required String mnemonic}) =>
    RustLib.instance.api.crateApiValidateMnemonic(mnemonic: mnemonic);

/// Get network info
Future<NetworkInfo> getNetworkInfo() =>
    RustLib.instance.api.crateApiGetNetworkInfo();

/// Format amount (arrrtoshis to ARRR)
Future<String> formatAmount({required BigInt arrrtoshis}) =>
    RustLib.instance.api.crateApiFormatAmount(arrrtoshis: arrrtoshis);

/// Parse amount (ARRR to arrrtoshis)
Future<BigInt> parseAmount({required String arrr}) =>
    RustLib.instance.api.crateApiParseAmount(arrr: arrr);

/// Set panic PIN for decoy vault
Future<void> setPanicPin({required String pin}) =>
    RustLib.instance.api.crateApiSetPanicPin(pin: pin);

/// Check if panic PIN is configured
Future<bool> hasPanicPin() => RustLib.instance.api.crateApiHasPanicPin();

/// Verify panic PIN (returns true if PIN matches and activates decoy mode)
Future<bool> verifyPanicPin({required String pin}) =>
    RustLib.instance.api.crateApiVerifyPanicPin(pin: pin);

/// Check if currently in decoy mode
Future<bool> isDecoyMode() => RustLib.instance.api.crateApiIsDecoyMode();

/// Get current vault mode
Future<String> getVaultMode() => RustLib.instance.api.crateApiGetVaultMode();

/// Clear panic PIN and disable decoy vault
Future<void> clearPanicPin() => RustLib.instance.api.crateApiClearPanicPin();

/// Set duress passphrase for decoy vault
/// Returns the Argon2id hash for secure storage on the client side.
Future<String> setDuressPassphrase({String? customPassphrase}) => RustLib
    .instance
    .api
    .crateApiSetDuressPassphrase(customPassphrase: customPassphrase);

/// Check if a duress passphrase is configured
Future<bool> hasDuressPassphrase() =>
    RustLib.instance.api.crateApiHasDuressPassphrase();

/// Get the stored duress passphrase hash (for client-side secure storage sync)
Future<String?> getDuressPassphraseHash() =>
    RustLib.instance.api.crateApiGetDuressPassphraseHash();

/// Clear duress passphrase configuration
Future<void> clearDuressPassphrase() =>
    RustLib.instance.api.crateApiClearDuressPassphrase();

/// Verify duress passphrase (activates decoy mode if correct)
Future<bool> verifyDuressPassphrase({
  required String passphrase,
  required String hash,
}) => RustLib.instance.api.crateApiVerifyDuressPassphrase(
  passphrase: passphrase,
  hash: hash,
);

/// Set decoy wallet name
Future<void> setDecoyWalletName({required String name}) =>
    RustLib.instance.api.crateApiSetDecoyWalletName(name: name);

/// Exit decoy mode (requires real passphrase re-authentication)
Future<void> exitDecoyMode() => RustLib.instance.api.crateApiExitDecoyMode();

/// Start seed export flow (step 1: show warning)
Future<String> startSeedExport({required String walletId}) =>
    RustLib.instance.api.crateApiStartSeedExport(walletId: walletId);

/// Acknowledge seed export warning (step 2)
Future<String> acknowledgeSeedWarning() =>
    RustLib.instance.api.crateApiAcknowledgeSeedWarning();

/// Complete biometric step (step 3)
Future<String> completeSeedBiometric({required bool success}) =>
    RustLib.instance.api.crateApiCompleteSeedBiometric(success: success);

/// Skip biometric (when not available)
Future<String> skipSeedBiometric() =>
    RustLib.instance.api.crateApiSkipSeedBiometric();

/// Verify passphrase and get seed (step 4 - final)
///
/// This is the final step of the gated seed export flow.
/// Verifies passphrase against stored Argon2id hash before returning the seed.
///
/// Note: Only works for wallets created/restored from seed.
/// Wallets imported from private key or watch-only wallets cannot export seed.
Future<List<String>> exportSeedWithPassphrase({
  required String walletId,
  required String passphrase,
}) => RustLib.instance.api.crateApiExportSeedWithPassphrase(
  walletId: walletId,
  passphrase: passphrase,
);

/// Export seed using cached app passphrase (after biometric approval).
Future<List<String>> exportSeedWithCachedPassphrase({
  required String walletId,
}) => RustLib.instance.api.crateApiExportSeedWithCachedPassphrase(
  walletId: walletId,
);

/// Cancel seed export flow
Future<void> cancelSeedExport() =>
    RustLib.instance.api.crateApiCancelSeedExport();

/// Get current seed export flow state
Future<String> getSeedExportState() =>
    RustLib.instance.api.crateApiGetSeedExportState();

/// Check if screenshots are blocked during export
Future<bool> areSeedScreenshotsBlocked() =>
    RustLib.instance.api.crateApiAreSeedScreenshotsBlocked();

/// Get clipboard auto-clear remaining seconds
Future<BigInt?> getSeedClipboardRemaining() =>
    RustLib.instance.api.crateApiGetSeedClipboardRemaining();

/// Get seed export warning messages
Future<SeedExportWarnings> getSeedExportWarnings() =>
    RustLib.instance.api.crateApiGetSeedExportWarnings();

/// Export Sapling viewing key from full wallet (for creating watch-only on another device)
Future<String> exportIvkSecure({required String walletId}) =>
    RustLib.instance.api.crateApiExportIvkSecure(walletId: walletId);

/// Import viewing key to create watch-only wallet
Future<String> importIvkAsWatchOnly({
  required String name,
  required String ivk,
  required int birthdayHeight,
}) => RustLib.instance.api.crateApiImportIvkAsWatchOnly(
  name: name,
  ivk: ivk,
  birthdayHeight: birthdayHeight,
);

/// Get watch-only capabilities for a wallet
Future<WatchOnlyCapabilitiesInfo> getWatchOnlyCapabilities({
  required String walletId,
}) => RustLib.instance.api.crateApiGetWatchOnlyCapabilities(walletId: walletId);

/// Get watch-only banner info for a wallet
Future<WatchOnlyBannerInfo?> getWatchOnlyBanner({required String walletId}) =>
    RustLib.instance.api.crateApiGetWatchOnlyBanner(walletId: walletId);

/// Check if viewing key clipboard should be cleared
Future<BigInt?> getIvkClipboardRemaining() =>
    RustLib.instance.api.crateApiGetIvkClipboardRemaining();

/// Get build information for verification
Future<BuildInfo> getBuildInfo() => RustLib.instance.api.crateApiGetBuildInfo();

/// Get sync logs for diagnostics
Future<List<SyncLogEntryFfi>> getSyncLogs({
  required String walletId,
  int? limit,
}) =>
    RustLib.instance.api.crateApiGetSyncLogs(walletId: walletId, limit: limit);

/// Get checkpoint details at specific height
Future<CheckpointInfo?> getCheckpointDetails({
  required String walletId,
  required int height,
}) => RustLib.instance.api.crateApiGetCheckpointDetails(
  walletId: walletId,
  height: height,
);

/// Test connection to a lightwalletd endpoint
Future<NodeTestResult> testNode({required String url, String? tlsPin}) =>
    RustLib.instance.api.crateApiTestNode(url: url, tlsPin: tlsPin);

/// Checkpoint information for diagnostics
class CheckpointInfo {
  /// Checkpoint block height
  final int height;

  /// Unix timestamp when checkpoint was created
  final PlatformInt64 timestamp;

  const CheckpointInfo({required this.height, required this.timestamp});

  @override
  int get hashCode => height.hashCode ^ timestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CheckpointInfo &&
          runtimeType == other.runtimeType &&
          height == other.height &&
          timestamp == other.timestamp;
}

/// Fee information for UI
class FeeInfo {
  /// Default fee (fixed)
  final BigInt defaultFee;

  /// Minimum allowed fee
  final BigInt minFee;

  /// Maximum allowed fee
  final BigInt maxFee;

  /// Additional fee per output (fixed fee uses 0)
  final BigInt feePerOutput;

  /// Fee multiplier when memo is included (fixed fee uses 1.0)
  final double memoFeeMultiplier;

  const FeeInfo({
    required this.defaultFee,
    required this.minFee,
    required this.maxFee,
    required this.feePerOutput,
    required this.memoFeeMultiplier,
  });

  @override
  int get hashCode =>
      defaultFee.hashCode ^
      minFee.hashCode ^
      maxFee.hashCode ^
      feePerOutput.hashCode ^
      memoFeeMultiplier.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FeeInfo &&
          runtimeType == other.runtimeType &&
          defaultFee == other.defaultFee &&
          minFee == other.minFee &&
          maxFee == other.maxFee &&
          feePerOutput == other.feePerOutput &&
          memoFeeMultiplier == other.memoFeeMultiplier;
}

/// Lightwalletd endpoint configuration
class LightdEndpoint {
  /// Server host
  final String host;

  /// Server port
  final int port;

  /// Whether TLS is enabled
  final bool useTls;

  /// Optional TLS certificate pin (SPKI hash, base64)
  final String? tlsPin;

  /// User label
  final String? label;

  const LightdEndpoint({
    required this.host,
    required this.port,
    required this.useTls,
    this.tlsPin,
    this.label,
  });

  static Future<LightdEndpoint> default_() =>
      RustLib.instance.api.crateApiLightdEndpointDefault();

  /// Display string (host:port)
  Future<String> displayString() =>
      RustLib.instance.api.crateApiLightdEndpointDisplayString(that: this);

  /// Full URL for gRPC connection
  Future<String> url() =>
      RustLib.instance.api.crateApiLightdEndpointUrl(that: this);

  @override
  int get hashCode =>
      host.hashCode ^
      port.hashCode ^
      useTls.hashCode ^
      tlsPin.hashCode ^
      label.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LightdEndpoint &&
          runtimeType == other.runtimeType &&
          host == other.host &&
          port == other.port &&
          useTls == other.useTls &&
          tlsPin == other.tlsPin &&
          label == other.label;
}

/// Seed export warning messages for UI
class SeedExportWarnings {
  final String primary;
  final String secondary;
  final String backupInstructions;
  final String clipboardWarning;

  const SeedExportWarnings({
    required this.primary,
    required this.secondary,
    required this.backupInstructions,
    required this.clipboardWarning,
  });

  @override
  int get hashCode =>
      primary.hashCode ^
      secondary.hashCode ^
      backupInstructions.hashCode ^
      clipboardWarning.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SeedExportWarnings &&
          runtimeType == other.runtimeType &&
          primary == other.primary &&
          secondary == other.secondary &&
          backupInstructions == other.backupInstructions &&
          clipboardWarning == other.clipboardWarning;
}

/// Watch-only banner info for FFI
class WatchOnlyBannerInfo {
  final String bannerType;
  final String title;
  final String subtitle;
  final String icon;

  const WatchOnlyBannerInfo({
    required this.bannerType,
    required this.title,
    required this.subtitle,
    required this.icon,
  });

  @override
  int get hashCode =>
      bannerType.hashCode ^ title.hashCode ^ subtitle.hashCode ^ icon.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WatchOnlyBannerInfo &&
          runtimeType == other.runtimeType &&
          bannerType == other.bannerType &&
          title == other.title &&
          subtitle == other.subtitle &&
          icon == other.icon;
}

/// Watch-only capabilities for FFI
class WatchOnlyCapabilitiesInfo {
  final bool canViewIncoming;
  final bool canViewOutgoing;
  final bool canSpend;
  final bool canExportSeed;
  final bool canGenerateAddresses;
  final bool isWatchOnly;

  const WatchOnlyCapabilitiesInfo({
    required this.canViewIncoming,
    required this.canViewOutgoing,
    required this.canSpend,
    required this.canExportSeed,
    required this.canGenerateAddresses,
    required this.isWatchOnly,
  });

  @override
  int get hashCode =>
      canViewIncoming.hashCode ^
      canViewOutgoing.hashCode ^
      canSpend.hashCode ^
      canExportSeed.hashCode ^
      canGenerateAddresses.hashCode ^
      isWatchOnly.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WatchOnlyCapabilitiesInfo &&
          runtimeType == other.runtimeType &&
          canViewIncoming == other.canViewIncoming &&
          canViewOutgoing == other.canViewOutgoing &&
          canSpend == other.canSpend &&
          canExportSeed == other.canExportSeed &&
          canGenerateAddresses == other.canGenerateAddresses &&
          isWatchOnly == other.isWatchOnly;
}

class WitnessRefreshOutcome {
  final String source;
  final BigInt saplingRequested;
  final BigInt saplingUpdated;
  final BigInt saplingMissing;
  final BigInt saplingErrors;
  final BigInt orchardRequested;
  final BigInt orchardUpdated;
  final BigInt orchardMissing;
  final BigInt orchardErrors;

  const WitnessRefreshOutcome({
    required this.source,
    required this.saplingRequested,
    required this.saplingUpdated,
    required this.saplingMissing,
    required this.saplingErrors,
    required this.orchardRequested,
    required this.orchardUpdated,
    required this.orchardMissing,
    required this.orchardErrors,
  });

  static Future<WitnessRefreshOutcome> default_() =>
      RustLib.instance.api.crateApiWitnessRefreshOutcomeDefault();

  @override
  int get hashCode =>
      source.hashCode ^
      saplingRequested.hashCode ^
      saplingUpdated.hashCode ^
      saplingMissing.hashCode ^
      saplingErrors.hashCode ^
      orchardRequested.hashCode ^
      orchardUpdated.hashCode ^
      orchardMissing.hashCode ^
      orchardErrors.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WitnessRefreshOutcome &&
          runtimeType == other.runtimeType &&
          source == other.source &&
          saplingRequested == other.saplingRequested &&
          saplingUpdated == other.saplingUpdated &&
          saplingMissing == other.saplingMissing &&
          saplingErrors == other.saplingErrors &&
          orchardRequested == other.orchardRequested &&
          orchardUpdated == other.orchardUpdated &&
          orchardMissing == other.orchardMissing &&
          orchardErrors == other.orchardErrors;
}
